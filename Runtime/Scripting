//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g 2012-01-06 21:54:55

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class MyLang3Lexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int T__7=7;
	public const int T__8=8;
	public const int IDENT=4;
	public const int INT=5;
	public const int WS=6;

    // delegates
    // delegators

	public MyLang3Lexer()
	{
		OnCreated();
	}

	public MyLang3Lexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public MyLang3Lexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_T__7();
	partial void LeaveRule_T__7();

	// $ANTLR start "T__7"
	[GrammarRule("T__7")]
	private void mT__7()
	{
		EnterRule_T__7();
		EnterRule("T__7", 1);
		TraceIn("T__7", 1);
		try
		{
			int _type = T__7;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:7:6: ( ':=' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:7:8: ':='
			{
			DebugLocation(7, 8);
			Match(":="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__7", 1);
			LeaveRule("T__7", 1);
			LeaveRule_T__7();
		}
	}
	// $ANTLR end "T__7"

	partial void EnterRule_T__8();
	partial void LeaveRule_T__8();

	// $ANTLR start "T__8"
	[GrammarRule("T__8")]
	private void mT__8()
	{
		EnterRule_T__8();
		EnterRule("T__8", 2);
		TraceIn("T__8", 2);
		try
		{
			int _type = T__8;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:8:6: ( ';' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:8:8: ';'
			{
			DebugLocation(8, 8);
			Match(';'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__8", 2);
			LeaveRule("T__8", 2);
			LeaveRule_T__8();
		}
	}
	// $ANTLR end "T__8"

	partial void EnterRule_IDENT();
	partial void LeaveRule_IDENT();

	// $ANTLR start "IDENT"
	[GrammarRule("IDENT")]
	private void mIDENT()
	{
		EnterRule_IDENT();
		EnterRule("IDENT", 3);
		TraceIn("IDENT", 3);
		try
		{
			int _type = IDENT;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:19:2: ( ( 'a' .. 'z' )+ )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:19:5: ( 'a' .. 'z' )+
			{
			DebugLocation(19, 5);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:19:5: ( 'a' .. 'z' )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>='a' && LA1_0<='z')))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:
					{
					DebugLocation(19, 5);
					input.Consume();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IDENT", 3);
			LeaveRule("IDENT", 3);
			LeaveRule_IDENT();
		}
	}
	// $ANTLR end "IDENT"

	partial void EnterRule_INT();
	partial void LeaveRule_INT();

	// $ANTLR start "INT"
	[GrammarRule("INT")]
	private void mINT()
	{
		EnterRule_INT();
		EnterRule("INT", 4);
		TraceIn("INT", 4);
		try
		{
			int _type = INT;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:22:5: ( ( '0' .. '9' )+ )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:22:7: ( '0' .. '9' )+
			{
			DebugLocation(22, 7);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:22:7: ( '0' .. '9' )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if (((LA2_0>='0' && LA2_0<='9')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:
					{
					DebugLocation(22, 7);
					input.Consume();


					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INT", 4);
			LeaveRule("INT", 4);
			LeaveRule_INT();
		}
	}
	// $ANTLR end "INT"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 5);
		TraceIn("WS", 5);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:25:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:25:9: ( ' ' | '\\t' | '\\r' | '\\n' )
			{
			DebugLocation(25, 9);
			if ((input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(29, 11);
			_channel=HIDDEN;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 5);
			LeaveRule("WS", 5);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	public override void mTokens()
	{
		// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:1:8: ( T__7 | T__8 | IDENT | INT | WS )
		int alt3=5;
		try { DebugEnterDecision(3, false);
		switch (input.LA(1))
		{
		case ':':
			{
			alt3 = 1;
			}
			break;
		case ';':
			{
			alt3 = 2;
			}
			break;
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':
			{
			alt3 = 3;
			}
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			{
			alt3 = 4;
			}
			break;
		case '\t':
		case '\n':
		case '\r':
		case ' ':
			{
			alt3 = 5;
			}
			break;
		default:
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
		}

		} finally { DebugExitDecision(3); }
		switch (alt3)
		{
		case 1:
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:1:10: T__7
			{
			DebugLocation(1, 10);
			mT__7(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:1:15: T__8
			{
			DebugLocation(1, 15);
			mT__8(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:1:20: IDENT
			{
			DebugLocation(1, 20);
			mIDENT(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:1:26: INT
			{
			DebugLocation(1, 26);
			mINT(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:1:30: WS
			{
			DebugLocation(1, 30);
			mWS(); 

			}
			break;

		}

	}


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

 
	#endregion

}
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g 2012-01-06 21:54:55

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class MyLang3Parser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "IDENT", "INT", "WS", "':='", "';'"
	};
	public const int EOF=-1;
	public const int T__7=7;
	public const int T__8=8;
	public const int IDENT=4;
	public const int INT=5;
	public const int WS=6;

	public MyLang3Parser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public MyLang3Parser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return MyLang3Parser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_evaluator();
	partial void LeaveRule_evaluator();

	// $ANTLR start "evaluator"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:10:1: evaluator : ( assignment )* INT EOF !;
	[GrammarRule("evaluator")]
	private AstParserRuleReturnScope<CommonTree, IToken> evaluator()
	{
		EnterRule_evaluator();
		EnterRule("evaluator", 1);
		TraceIn("evaluator", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INT2 = default(IToken);
		IToken EOF3 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignment1 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INT2_tree = default(CommonTree);
		CommonTree EOF3_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "evaluator");
		DebugLocation(10, 1);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:11:2: ( ( assignment )* INT EOF !)
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:11:4: ( assignment )* INT EOF !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(11, 4);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:11:4: ( assignment )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==IDENT))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:11:4: assignment
					{
					DebugLocation(11, 4);
					PushFollow(Follow._assignment_in_evaluator40);
					assignment1=assignment();
					PopFollow();

					adaptor.AddChild(root_0, assignment1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(11, 16);
			INT2=(IToken)Match(input,INT,Follow._INT_in_evaluator43); 
			INT2_tree = (CommonTree)adaptor.Create(INT2);
			adaptor.AddChild(root_0, INT2_tree);
			DebugLocation(11, 23);
			EOF3=(IToken)Match(input,EOF,Follow._EOF_in_evaluator45); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("evaluator", 1);
			LeaveRule("evaluator", 1);
			LeaveRule_evaluator();
		}
		DebugLocation(12, 1);
		} finally { DebugExitRule(GrammarFileName, "evaluator"); }
		return retval;

	}
	// $ANTLR end "evaluator"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();

	// $ANTLR start "assignment"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:14:1: assignment : IDENT ':=' ^ INT ';' !;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 2);
		TraceIn("assignment", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT4 = default(IToken);
		IToken string_literal5 = default(IToken);
		IToken INT6 = default(IToken);
		IToken char_literal7 = default(IToken);

		CommonTree IDENT4_tree = default(CommonTree);
		CommonTree string_literal5_tree = default(CommonTree);
		CommonTree INT6_tree = default(CommonTree);
		CommonTree char_literal7_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(14, 1);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:15:2: ( IDENT ':=' ^ INT ';' !)
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:15:4: IDENT ':=' ^ INT ';' !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(15, 4);
			IDENT4=(IToken)Match(input,IDENT,Follow._IDENT_in_assignment58); 
			IDENT4_tree = (CommonTree)adaptor.Create(IDENT4);
			adaptor.AddChild(root_0, IDENT4_tree);
			DebugLocation(15, 14);
			string_literal5=(IToken)Match(input,7,Follow._7_in_assignment60); 
			string_literal5_tree = (CommonTree)adaptor.Create(string_literal5);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal5_tree, root_0);
			DebugLocation(15, 16);
			INT6=(IToken)Match(input,INT,Follow._INT_in_assignment63); 
			INT6_tree = (CommonTree)adaptor.Create(INT6);
			adaptor.AddChild(root_0, INT6_tree);
			DebugLocation(15, 23);
			char_literal7=(IToken)Match(input,8,Follow._8_in_assignment65); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 2);
			LeaveRule("assignment", 2);
			LeaveRule_assignment();
		}
		DebugLocation(16, 1);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _assignment_in_evaluator40 = new BitSet(new ulong[]{0x30UL});
		public static readonly BitSet _INT_in_evaluator43 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_evaluator45 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_assignment58 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _7_in_assignment60 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _INT_in_assignment63 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _8_in_assignment65 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g 2012-01-06 22:53:23

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

   
    // turn of unreachable code warnings
    // turn off obsolete code warnings
    // turn off unused variable
    # pragma warning disable 0162,0618,0219 
    using System.Text;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  PlayingWithDLR.MyScriptRuntime.Script 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class MyLangLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int AND=4;
	public const int ASSIGN=5;
	public const int BLOCKSTMT=6;
	public const int CALL=7;
	public const int COLON=8;
	public const int COMMA=9;
	public const int COMMENT=10;
	public const int DECLARE=11;
	public const int DIGIT=12;
	public const int DIVIDE=13;
	public const int DOT=14;
	public const int ELSE=15;
	public const int ENDP=16;
	public const int EQUALS=17;
	public const int EXPONENT=18;
	public const int FLOAT=19;
	public const int FUNCCALL=20;
	public const int FUNCDECL=21;
	public const int FUNCTION=22;
	public const int GT=23;
	public const int GTEQ=24;
	public const int IDENTIFIER=25;
	public const int IF=26;
	public const int INT=27;
	public const int LCLETTER=28;
	public const int LCURLY=29;
	public const int LPAREN=30;
	public const int LT=31;
	public const int LTEQ=32;
	public const int MINUS=33;
	public const int MULTIPLY=34;
	public const int NEGATE=35;
	public const int OR=36;
	public const int PLUS=37;
	public const int PROGDECL=38;
	public const int PROGRAM=39;
	public const int RCURLY=40;
	public const int RETURN=41;
	public const int RPAREN=42;
	public const int RUN=43;
	public const int RUNPROG=44;
	public const int SEMI=45;
	public const int THEN=46;
	public const int UCLETTER=47;
	public const int USCORE=48;
	public const int VAR=49;
	public const int WHILE=50;
	public const int WS=51;

    // delegates
    // delegators

	public MyLangLexer()
	{
		OnCreated();
	}

	public MyLangLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public MyLangLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_ENDP();
	partial void LeaveRule_ENDP();

	// $ANTLR start "ENDP"
	[GrammarRule("ENDP")]
	private void mENDP()
	{
		EnterRule_ENDP();
		EnterRule("ENDP", 1);
		TraceIn("ENDP", 1);
		try
		{
			int _type = ENDP;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:30:7: ( 'end' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:30:9: 'end'
			{
			DebugLocation(30, 9);
			Match("end"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ENDP", 1);
			LeaveRule("ENDP", 1);
			LeaveRule_ENDP();
		}
	}
	// $ANTLR end "ENDP"

	partial void EnterRule_ASSIGN();
	partial void LeaveRule_ASSIGN();

	// $ANTLR start "ASSIGN"
	[GrammarRule("ASSIGN")]
	private void mASSIGN()
	{
		EnterRule_ASSIGN();
		EnterRule("ASSIGN", 2);
		TraceIn("ASSIGN", 2);
		try
		{
			int _type = ASSIGN;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:32:9: ( ':=' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:32:11: ':='
			{
			DebugLocation(32, 11);
			Match(":="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ASSIGN", 2);
			LeaveRule("ASSIGN", 2);
			LeaveRule_ASSIGN();
		}
	}
	// $ANTLR end "ASSIGN"

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 3);
		TraceIn("PLUS", 3);
		try
		{
			int _type = PLUS;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:34:9: ( '+' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:34:11: '+'
			{
			DebugLocation(34, 11);
			Match('+'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS", 3);
			LeaveRule("PLUS", 3);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_MINUS();
	partial void LeaveRule_MINUS();

	// $ANTLR start "MINUS"
	[GrammarRule("MINUS")]
	private void mMINUS()
	{
		EnterRule_MINUS();
		EnterRule("MINUS", 4);
		TraceIn("MINUS", 4);
		try
		{
			int _type = MINUS;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:36:9: ( '-' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:36:11: '-'
			{
			DebugLocation(36, 11);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MINUS", 4);
			LeaveRule("MINUS", 4);
			LeaveRule_MINUS();
		}
	}
	// $ANTLR end "MINUS"

	partial void EnterRule_MULTIPLY();
	partial void LeaveRule_MULTIPLY();

	// $ANTLR start "MULTIPLY"
	[GrammarRule("MULTIPLY")]
	private void mMULTIPLY()
	{
		EnterRule_MULTIPLY();
		EnterRule("MULTIPLY", 5);
		TraceIn("MULTIPLY", 5);
		try
		{
			int _type = MULTIPLY;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:38:9: ( '*' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:38:11: '*'
			{
			DebugLocation(38, 11);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MULTIPLY", 5);
			LeaveRule("MULTIPLY", 5);
			LeaveRule_MULTIPLY();
		}
	}
	// $ANTLR end "MULTIPLY"

	partial void EnterRule_DIVIDE();
	partial void LeaveRule_DIVIDE();

	// $ANTLR start "DIVIDE"
	[GrammarRule("DIVIDE")]
	private void mDIVIDE()
	{
		EnterRule_DIVIDE();
		EnterRule("DIVIDE", 6);
		TraceIn("DIVIDE", 6);
		try
		{
			int _type = DIVIDE;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:40:9: ( '/' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:40:11: '/'
			{
			DebugLocation(40, 11);
			Match('/'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DIVIDE", 6);
			LeaveRule("DIVIDE", 6);
			LeaveRule_DIVIDE();
		}
	}
	// $ANTLR end "DIVIDE"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 7);
		TraceIn("LPAREN", 7);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:42:9: ( '(' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:42:11: '('
			{
			DebugLocation(42, 11);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 7);
			LeaveRule("LPAREN", 7);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 8);
		TraceIn("RPAREN", 8);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:44:9: ( ')' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:44:11: ')'
			{
			DebugLocation(44, 11);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 8);
			LeaveRule("RPAREN", 8);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_EQUALS();
	partial void LeaveRule_EQUALS();

	// $ANTLR start "EQUALS"
	[GrammarRule("EQUALS")]
	private void mEQUALS()
	{
		EnterRule_EQUALS();
		EnterRule("EQUALS", 9);
		TraceIn("EQUALS", 9);
		try
		{
			int _type = EQUALS;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:46:8: ( '==' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:46:10: '=='
			{
			DebugLocation(46, 10);
			Match("=="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQUALS", 9);
			LeaveRule("EQUALS", 9);
			LeaveRule_EQUALS();
		}
	}
	// $ANTLR end "EQUALS"

	partial void EnterRule_GT();
	partial void LeaveRule_GT();

	// $ANTLR start "GT"
	[GrammarRule("GT")]
	private void mGT()
	{
		EnterRule_GT();
		EnterRule("GT", 10);
		TraceIn("GT", 10);
		try
		{
			int _type = GT;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:48:4: ( '>' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:48:6: '>'
			{
			DebugLocation(48, 6);
			Match('>'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GT", 10);
			LeaveRule("GT", 10);
			LeaveRule_GT();
		}
	}
	// $ANTLR end "GT"

	partial void EnterRule_LT();
	partial void LeaveRule_LT();

	// $ANTLR start "LT"
	[GrammarRule("LT")]
	private void mLT()
	{
		EnterRule_LT();
		EnterRule("LT", 11);
		TraceIn("LT", 11);
		try
		{
			int _type = LT;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:50:4: ( '<' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:50:6: '<'
			{
			DebugLocation(50, 6);
			Match('<'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LT", 11);
			LeaveRule("LT", 11);
			LeaveRule_LT();
		}
	}
	// $ANTLR end "LT"

	partial void EnterRule_LTEQ();
	partial void LeaveRule_LTEQ();

	// $ANTLR start "LTEQ"
	[GrammarRule("LTEQ")]
	private void mLTEQ()
	{
		EnterRule_LTEQ();
		EnterRule("LTEQ", 12);
		TraceIn("LTEQ", 12);
		try
		{
			int _type = LTEQ;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:52:6: ( '<=' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:52:8: '<='
			{
			DebugLocation(52, 8);
			Match("<="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LTEQ", 12);
			LeaveRule("LTEQ", 12);
			LeaveRule_LTEQ();
		}
	}
	// $ANTLR end "LTEQ"

	partial void EnterRule_GTEQ();
	partial void LeaveRule_GTEQ();

	// $ANTLR start "GTEQ"
	[GrammarRule("GTEQ")]
	private void mGTEQ()
	{
		EnterRule_GTEQ();
		EnterRule("GTEQ", 13);
		TraceIn("GTEQ", 13);
		try
		{
			int _type = GTEQ;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:54:6: ( '=>' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:54:8: '=>'
			{
			DebugLocation(54, 8);
			Match("=>"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GTEQ", 13);
			LeaveRule("GTEQ", 13);
			LeaveRule_GTEQ();
		}
	}
	// $ANTLR end "GTEQ"

	partial void EnterRule_OR();
	partial void LeaveRule_OR();

	// $ANTLR start "OR"
	[GrammarRule("OR")]
	private void mOR()
	{
		EnterRule_OR();
		EnterRule("OR", 14);
		TraceIn("OR", 14);
		try
		{
			int _type = OR;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:56:9: ( 'OR' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:56:11: 'OR'
			{
			DebugLocation(56, 11);
			Match("OR"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OR", 14);
			LeaveRule("OR", 14);
			LeaveRule_OR();
		}
	}
	// $ANTLR end "OR"

	partial void EnterRule_AND();
	partial void LeaveRule_AND();

	// $ANTLR start "AND"
	[GrammarRule("AND")]
	private void mAND()
	{
		EnterRule_AND();
		EnterRule("AND", 15);
		TraceIn("AND", 15);
		try
		{
			int _type = AND;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:58:9: ( 'AND' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:58:11: 'AND'
			{
			DebugLocation(58, 11);
			Match("AND"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AND", 15);
			LeaveRule("AND", 15);
			LeaveRule_AND();
		}
	}
	// $ANTLR end "AND"

	partial void EnterRule_WHILE();
	partial void LeaveRule_WHILE();

	// $ANTLR start "WHILE"
	[GrammarRule("WHILE")]
	private void mWHILE()
	{
		EnterRule_WHILE();
		EnterRule("WHILE", 16);
		TraceIn("WHILE", 16);
		try
		{
			int _type = WHILE;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:60:9: ( 'while' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:60:11: 'while'
			{
			DebugLocation(60, 11);
			Match("while"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHILE", 16);
			LeaveRule("WHILE", 16);
			LeaveRule_WHILE();
		}
	}
	// $ANTLR end "WHILE"

	partial void EnterRule_DECLARE();
	partial void LeaveRule_DECLARE();

	// $ANTLR start "DECLARE"
	[GrammarRule("DECLARE")]
	private void mDECLARE()
	{
		EnterRule_DECLARE();
		EnterRule("DECLARE", 17);
		TraceIn("DECLARE", 17);
		try
		{
			int _type = DECLARE;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:62:9: ( 'declare' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:62:11: 'declare'
			{
			DebugLocation(62, 11);
			Match("declare"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DECLARE", 17);
			LeaveRule("DECLARE", 17);
			LeaveRule_DECLARE();
		}
	}
	// $ANTLR end "DECLARE"

	partial void EnterRule_PROGRAM();
	partial void LeaveRule_PROGRAM();

	// $ANTLR start "PROGRAM"
	[GrammarRule("PROGRAM")]
	private void mPROGRAM()
	{
		EnterRule_PROGRAM();
		EnterRule("PROGRAM", 18);
		TraceIn("PROGRAM", 18);
		try
		{
			int _type = PROGRAM;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:64:9: ( 'program' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:64:11: 'program'
			{
			DebugLocation(64, 11);
			Match("program"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PROGRAM", 18);
			LeaveRule("PROGRAM", 18);
			LeaveRule_PROGRAM();
		}
	}
	// $ANTLR end "PROGRAM"

	partial void EnterRule_FUNCTION();
	partial void LeaveRule_FUNCTION();

	// $ANTLR start "FUNCTION"
	[GrammarRule("FUNCTION")]
	private void mFUNCTION()
	{
		EnterRule_FUNCTION();
		EnterRule("FUNCTION", 19);
		TraceIn("FUNCTION", 19);
		try
		{
			int _type = FUNCTION;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:66:10: ( 'function' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:66:12: 'function'
			{
			DebugLocation(66, 12);
			Match("function"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FUNCTION", 19);
			LeaveRule("FUNCTION", 19);
			LeaveRule_FUNCTION();
		}
	}
	// $ANTLR end "FUNCTION"

	partial void EnterRule_IF();
	partial void LeaveRule_IF();

	// $ANTLR start "IF"
	[GrammarRule("IF")]
	private void mIF()
	{
		EnterRule_IF();
		EnterRule("IF", 20);
		TraceIn("IF", 20);
		try
		{
			int _type = IF;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:68:4: ( 'if' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:68:6: 'if'
			{
			DebugLocation(68, 6);
			Match("if"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IF", 20);
			LeaveRule("IF", 20);
			LeaveRule_IF();
		}
	}
	// $ANTLR end "IF"

	partial void EnterRule_RUN();
	partial void LeaveRule_RUN();

	// $ANTLR start "RUN"
	[GrammarRule("RUN")]
	private void mRUN()
	{
		EnterRule_RUN();
		EnterRule("RUN", 21);
		TraceIn("RUN", 21);
		try
		{
			int _type = RUN;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:70:5: ( 'run' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:70:7: 'run'
			{
			DebugLocation(70, 7);
			Match("run"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RUN", 21);
			LeaveRule("RUN", 21);
			LeaveRule_RUN();
		}
	}
	// $ANTLR end "RUN"

	partial void EnterRule_THEN();
	partial void LeaveRule_THEN();

	// $ANTLR start "THEN"
	[GrammarRule("THEN")]
	private void mTHEN()
	{
		EnterRule_THEN();
		EnterRule("THEN", 22);
		TraceIn("THEN", 22);
		try
		{
			int _type = THEN;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:72:6: ( 'then' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:72:8: 'then'
			{
			DebugLocation(72, 8);
			Match("then"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("THEN", 22);
			LeaveRule("THEN", 22);
			LeaveRule_THEN();
		}
	}
	// $ANTLR end "THEN"

	partial void EnterRule_ELSE();
	partial void LeaveRule_ELSE();

	// $ANTLR start "ELSE"
	[GrammarRule("ELSE")]
	private void mELSE()
	{
		EnterRule_ELSE();
		EnterRule("ELSE", 23);
		TraceIn("ELSE", 23);
		try
		{
			int _type = ELSE;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:74:6: ( 'else' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:74:8: 'else'
			{
			DebugLocation(74, 8);
			Match("else"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ELSE", 23);
			LeaveRule("ELSE", 23);
			LeaveRule_ELSE();
		}
	}
	// $ANTLR end "ELSE"

	partial void EnterRule_CALL();
	partial void LeaveRule_CALL();

	// $ANTLR start "CALL"
	[GrammarRule("CALL")]
	private void mCALL()
	{
		EnterRule_CALL();
		EnterRule("CALL", 24);
		TraceIn("CALL", 24);
		try
		{
			int _type = CALL;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:76:6: ( 'call' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:76:8: 'call'
			{
			DebugLocation(76, 8);
			Match("call"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CALL", 24);
			LeaveRule("CALL", 24);
			LeaveRule_CALL();
		}
	}
	// $ANTLR end "CALL"

	partial void EnterRule_RETURN();
	partial void LeaveRule_RETURN();

	// $ANTLR start "RETURN"
	[GrammarRule("RETURN")]
	private void mRETURN()
	{
		EnterRule_RETURN();
		EnterRule("RETURN", 25);
		TraceIn("RETURN", 25);
		try
		{
			int _type = RETURN;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:78:8: ( 'return' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:78:10: 'return'
			{
			DebugLocation(78, 10);
			Match("return"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RETURN", 25);
			LeaveRule("RETURN", 25);
			LeaveRule_RETURN();
		}
	}
	// $ANTLR end "RETURN"

	partial void EnterRule_LCURLY();
	partial void LeaveRule_LCURLY();

	// $ANTLR start "LCURLY"
	[GrammarRule("LCURLY")]
	private void mLCURLY()
	{
		EnterRule_LCURLY();
		EnterRule("LCURLY", 26);
		TraceIn("LCURLY", 26);
		try
		{
			int _type = LCURLY;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:80:8: ( '{' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:80:10: '{'
			{
			DebugLocation(80, 10);
			Match('{'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LCURLY", 26);
			LeaveRule("LCURLY", 26);
			LeaveRule_LCURLY();
		}
	}
	// $ANTLR end "LCURLY"

	partial void EnterRule_RCURLY();
	partial void LeaveRule_RCURLY();

	// $ANTLR start "RCURLY"
	[GrammarRule("RCURLY")]
	private void mRCURLY()
	{
		EnterRule_RCURLY();
		EnterRule("RCURLY", 27);
		TraceIn("RCURLY", 27);
		try
		{
			int _type = RCURLY;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:82:8: ( '}' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:82:10: '}'
			{
			DebugLocation(82, 10);
			Match('}'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RCURLY", 27);
			LeaveRule("RCURLY", 27);
			LeaveRule_RCURLY();
		}
	}
	// $ANTLR end "RCURLY"

	partial void EnterRule_SEMI();
	partial void LeaveRule_SEMI();

	// $ANTLR start "SEMI"
	[GrammarRule("SEMI")]
	private void mSEMI()
	{
		EnterRule_SEMI();
		EnterRule("SEMI", 28);
		TraceIn("SEMI", 28);
		try
		{
			int _type = SEMI;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:84:5: ( ';' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:84:7: ';'
			{
			DebugLocation(84, 7);
			Match(';'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SEMI", 28);
			LeaveRule("SEMI", 28);
			LeaveRule_SEMI();
		}
	}
	// $ANTLR end "SEMI"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 29);
		TraceIn("WS", 29);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:86:4: ( ( ' ' | '\\t' | '\\n' | '\\r' | '\\f' )+ )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:86:6: ( ' ' | '\\t' | '\\n' | '\\r' | '\\f' )+
			{
			DebugLocation(86, 6);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:86:6: ( ' ' | '\\t' | '\\n' | '\\r' | '\\f' )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>='\t' && LA1_0<='\n')||(LA1_0>='\f' && LA1_0<='\r')||LA1_0==' '))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:
					{
					DebugLocation(86, 6);
					input.Consume();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(86, 41);
			_channel = Hidden;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 29);
			LeaveRule("WS", 29);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	partial void EnterRule_COMMENT();
	partial void LeaveRule_COMMENT();

	// $ANTLR start "COMMENT"
	[GrammarRule("COMMENT")]
	private void mCOMMENT()
	{
		EnterRule_COMMENT();
		EnterRule("COMMENT", 30);
		TraceIn("COMMENT", 30);
		try
		{
			int _type = COMMENT;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:89:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/*' ( options {greedy=false; } : . )* '*/' )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0=='/'))
			{
				int LA5_1 = input.LA(2);

				if ((LA5_1=='/'))
				{
					alt5 = 1;
				}
				else if ((LA5_1=='*'))
				{
					alt5 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:89:9: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
				{
				DebugLocation(89, 9);
				Match("//"); 

				DebugLocation(89, 14);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:89:14: (~ ( '\\n' | '\\r' ) )*
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_0 = input.LA(1);

					if (((LA2_0>='\u0000' && LA2_0<='\t')||(LA2_0>='\u000B' && LA2_0<='\f')||(LA2_0>='\u000E' && LA2_0<='\uFFFF')))
					{
						alt2 = 1;
					}


					} finally { DebugExitDecision(2); }
					switch ( alt2 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:
						{
						DebugLocation(89, 14);
						input.Consume();


						}
						break;

					default:
						goto loop2;
					}
				}

				loop2:
					;

				} finally { DebugExitSubRule(2); }

				DebugLocation(89, 28);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:89:28: ( '\\r' )?
				int alt3=2;
				try { DebugEnterSubRule(3);
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0=='\r'))
				{
					alt3 = 1;
				}
				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:89:28: '\\r'
					{
					DebugLocation(89, 28);
					Match('\r'); 

					}
					break;

				}
				} finally { DebugExitSubRule(3); }

				DebugLocation(89, 34);
				Match('\n'); 
				DebugLocation(89, 39);
				_channel=Hidden;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:90:9: '/*' ( options {greedy=false; } : . )* '*/'
				{
				DebugLocation(90, 9);
				Match("/*"); 

				DebugLocation(90, 14);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:90:14: ( options {greedy=false; } : . )*
				try { DebugEnterSubRule(4);
				while (true)
				{
					int alt4=2;
					try { DebugEnterDecision(4, false);
					int LA4_0 = input.LA(1);

					if ((LA4_0=='*'))
					{
						int LA4_1 = input.LA(2);

						if ((LA4_1=='/'))
						{
							alt4 = 2;
						}
						else if (((LA4_1>='\u0000' && LA4_1<='.')||(LA4_1>='0' && LA4_1<='\uFFFF')))
						{
							alt4 = 1;
						}


					}
					else if (((LA4_0>='\u0000' && LA4_0<=')')||(LA4_0>='+' && LA4_0<='\uFFFF')))
					{
						alt4 = 1;
					}


					} finally { DebugExitDecision(4); }
					switch ( alt4 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:90:42: .
						{
						DebugLocation(90, 42);
						MatchAny(); 

						}
						break;

					default:
						goto loop4;
					}
				}

				loop4:
					;

				} finally { DebugExitSubRule(4); }

				DebugLocation(90, 47);
				Match("*/"); 

				DebugLocation(90, 52);
				_channel=Hidden;

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMENT", 30);
			LeaveRule("COMMENT", 30);
			LeaveRule_COMMENT();
		}
	}
	// $ANTLR end "COMMENT"

	partial void EnterRule_INT();
	partial void LeaveRule_INT();

	// $ANTLR start "INT"
	[GrammarRule("INT")]
	private void mINT()
	{
		EnterRule_INT();
		EnterRule("INT", 31);
		TraceIn("INT", 31);
		try
		{
			int _type = INT;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:93:9: ( ( DIGIT )+ )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:93:11: ( DIGIT )+
			{
			DebugLocation(93, 11);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:93:11: ( DIGIT )+
			int cnt6=0;
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if (((LA6_0>='0' && LA6_0<='9')))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:
					{
					DebugLocation(93, 11);
					input.Consume();


					}
					break;

				default:
					if (cnt6 >= 1)
						goto loop6;

					EarlyExitException eee6 = new EarlyExitException( 6, input );
					DebugRecognitionException(eee6);
					throw eee6;
				}
				cnt6++;
			}
			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INT", 31);
			LeaveRule("INT", 31);
			LeaveRule_INT();
		}
	}
	// $ANTLR end "INT"

	partial void EnterRule_FLOAT();
	partial void LeaveRule_FLOAT();

	// $ANTLR start "FLOAT"
	[GrammarRule("FLOAT")]
	private void mFLOAT()
	{
		EnterRule_FLOAT();
		EnterRule("FLOAT", 32);
		TraceIn("FLOAT", 32);
		try
		{
			int _type = FLOAT;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:96:5: ( ( DIGIT )+ DOT ( DIGIT )+ )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:96:9: ( DIGIT )+ DOT ( DIGIT )+
			{
			DebugLocation(96, 9);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:96:9: ( DIGIT )+
			int cnt7=0;
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if (((LA7_0>='0' && LA7_0<='9')))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:
					{
					DebugLocation(96, 9);
					input.Consume();


					}
					break;

				default:
					if (cnt7 >= 1)
						goto loop7;

					EarlyExitException eee7 = new EarlyExitException( 7, input );
					DebugRecognitionException(eee7);
					throw eee7;
				}
				cnt7++;
			}
			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(96, 16);
			mDOT(); 
			DebugLocation(96, 20);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:96:20: ( DIGIT )+
			int cnt8=0;
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if (((LA8_0>='0' && LA8_0<='9')))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:
					{
					DebugLocation(96, 20);
					input.Consume();


					}
					break;

				default:
					if (cnt8 >= 1)
						goto loop8;

					EarlyExitException eee8 = new EarlyExitException( 8, input );
					DebugRecognitionException(eee8);
					throw eee8;
				}
				cnt8++;
			}
			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FLOAT", 32);
			LeaveRule("FLOAT", 32);
			LeaveRule_FLOAT();
		}
	}
	// $ANTLR end "FLOAT"

	partial void EnterRule_IDENTIFIER();
	partial void LeaveRule_IDENTIFIER();

	// $ANTLR start "IDENTIFIER"
	[GrammarRule("IDENTIFIER")]
	private void mIDENTIFIER()
	{
		EnterRule_IDENTIFIER();
		EnterRule("IDENTIFIER", 33);
		TraceIn("IDENTIFIER", 33);
		try
		{
			int _type = IDENTIFIER;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:107:13: ( ( LCLETTER | UCLETTER | USCORE ) ( LCLETTER | UCLETTER | DIGIT | USCORE )* )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:107:17: ( LCLETTER | UCLETTER | USCORE ) ( LCLETTER | UCLETTER | DIGIT | USCORE )*
			{
			DebugLocation(107, 17);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(107, 44);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:107:44: ( LCLETTER | UCLETTER | DIGIT | USCORE )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if (((LA9_0>='0' && LA9_0<='9')||(LA9_0>='A' && LA9_0<='Z')||LA9_0=='_'||(LA9_0>='a' && LA9_0<='z')))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:
					{
					DebugLocation(107, 44);
					input.Consume();


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IDENTIFIER", 33);
			LeaveRule("IDENTIFIER", 33);
			LeaveRule_IDENTIFIER();
		}
	}
	// $ANTLR end "IDENTIFIER"

	partial void EnterRule_COMMA();
	partial void LeaveRule_COMMA();

	// $ANTLR start "COMMA"
	[GrammarRule("COMMA")]
	private void mCOMMA()
	{
		EnterRule_COMMA();
		EnterRule("COMMA", 34);
		TraceIn("COMMA", 34);
		try
		{
			int _type = COMMA;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:110:7: ( ',' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:110:9: ','
			{
			DebugLocation(110, 9);
			Match(','); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMA", 34);
			LeaveRule("COMMA", 34);
			LeaveRule_COMMA();
		}
	}
	// $ANTLR end "COMMA"

	partial void EnterRule_COLON();
	partial void LeaveRule_COLON();

	// $ANTLR start "COLON"
	[GrammarRule("COLON")]
	private void mCOLON()
	{
		EnterRule_COLON();
		EnterRule("COLON", 35);
		TraceIn("COLON", 35);
		try
		{
			int _type = COLON;
			int _channel = DefaultTokenChannel;
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:113:6: ( ':' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:113:8: ':'
			{
			DebugLocation(113, 8);
			Match(':'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COLON", 35);
			LeaveRule("COLON", 35);
			LeaveRule_COLON();
		}
	}
	// $ANTLR end "COLON"

	partial void EnterRule_EXPONENT();
	partial void LeaveRule_EXPONENT();

	// $ANTLR start "EXPONENT"
	[GrammarRule("EXPONENT")]
	private void mEXPONENT()
	{
		EnterRule_EXPONENT();
		EnterRule("EXPONENT", 36);
		TraceIn("EXPONENT", 36);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:116:10: ( ( 'e' | 'E' ) ( PLUS | MINUS )? ( DIGIT )+ )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:116:12: ( 'e' | 'E' ) ( PLUS | MINUS )? ( DIGIT )+
			{
			DebugLocation(116, 12);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(116, 22);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:116:22: ( PLUS | MINUS )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0=='+'||LA10_0=='-'))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:
				{
				DebugLocation(116, 22);
				input.Consume();


				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(116, 36);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:116:36: ( DIGIT )+
			int cnt11=0;
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if (((LA11_0>='0' && LA11_0<='9')))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:
					{
					DebugLocation(116, 36);
					input.Consume();


					}
					break;

				default:
					if (cnt11 >= 1)
						goto loop11;

					EarlyExitException eee11 = new EarlyExitException( 11, input );
					DebugRecognitionException(eee11);
					throw eee11;
				}
				cnt11++;
			}
			loop11:
				;

			} finally { DebugExitSubRule(11); }


			}

		}
		finally
		{
			TraceOut("EXPONENT", 36);
			LeaveRule("EXPONENT", 36);
			LeaveRule_EXPONENT();
		}
	}
	// $ANTLR end "EXPONENT"

	partial void EnterRule_DOT();
	partial void LeaveRule_DOT();

	// $ANTLR start "DOT"
	[GrammarRule("DOT")]
	private void mDOT()
	{
		EnterRule_DOT();
		EnterRule("DOT", 37);
		TraceIn("DOT", 37);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:119:9: ( '.' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:119:11: '.'
			{
			DebugLocation(119, 11);
			Match('.'); 

			}

		}
		finally
		{
			TraceOut("DOT", 37);
			LeaveRule("DOT", 37);
			LeaveRule_DOT();
		}
	}
	// $ANTLR end "DOT"

	partial void EnterRule_USCORE();
	partial void LeaveRule_USCORE();

	// $ANTLR start "USCORE"
	[GrammarRule("USCORE")]
	private void mUSCORE()
	{
		EnterRule_USCORE();
		EnterRule("USCORE", 38);
		TraceIn("USCORE", 38);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:122:9: ( '_' )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:122:11: '_'
			{
			DebugLocation(122, 11);
			Match('_'); 

			}

		}
		finally
		{
			TraceOut("USCORE", 38);
			LeaveRule("USCORE", 38);
			LeaveRule_USCORE();
		}
	}
	// $ANTLR end "USCORE"

	partial void EnterRule_DIGIT();
	partial void LeaveRule_DIGIT();

	// $ANTLR start "DIGIT"
	[GrammarRule("DIGIT")]
	private void mDIGIT()
	{
		EnterRule_DIGIT();
		EnterRule("DIGIT", 39);
		TraceIn("DIGIT", 39);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:125:9: ( ( '0' .. '9' ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:
			{
			DebugLocation(125, 9);
			if ((input.LA(1)>='0' && input.LA(1)<='9'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("DIGIT", 39);
			LeaveRule("DIGIT", 39);
			LeaveRule_DIGIT();
		}
	}
	// $ANTLR end "DIGIT"

	partial void EnterRule_LCLETTER();
	partial void LeaveRule_LCLETTER();

	// $ANTLR start "LCLETTER"
	[GrammarRule("LCLETTER")]
	private void mLCLETTER()
	{
		EnterRule_LCLETTER();
		EnterRule("LCLETTER", 40);
		TraceIn("LCLETTER", 40);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:128:9: ( ( 'a' .. 'z' ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:
			{
			DebugLocation(128, 9);
			if ((input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("LCLETTER", 40);
			LeaveRule("LCLETTER", 40);
			LeaveRule_LCLETTER();
		}
	}
	// $ANTLR end "LCLETTER"

	partial void EnterRule_UCLETTER();
	partial void LeaveRule_UCLETTER();

	// $ANTLR start "UCLETTER"
	[GrammarRule("UCLETTER")]
	private void mUCLETTER()
	{
		EnterRule_UCLETTER();
		EnterRule("UCLETTER", 41);
		TraceIn("UCLETTER", 41);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:131:9: ( ( 'A' .. 'Z' ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:
			{
			DebugLocation(131, 9);
			if ((input.LA(1)>='A' && input.LA(1)<='Z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("UCLETTER", 41);
			LeaveRule("UCLETTER", 41);
			LeaveRule_UCLETTER();
		}
	}
	// $ANTLR end "UCLETTER"

	public override void mTokens()
	{
		// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:8: ( ENDP | ASSIGN | PLUS | MINUS | MULTIPLY | DIVIDE | LPAREN | RPAREN | EQUALS | GT | LT | LTEQ | GTEQ | OR | AND | WHILE | DECLARE | PROGRAM | FUNCTION | IF | RUN | THEN | ELSE | CALL | RETURN | LCURLY | RCURLY | SEMI | WS | COMMENT | INT | FLOAT | IDENTIFIER | COMMA | COLON )
		int alt12=35;
		try { DebugEnterDecision(12, false);
		try
		{
			alt12 = dfa12.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(12); }
		switch (alt12)
		{
		case 1:
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:10: ENDP
			{
			DebugLocation(1, 10);
			mENDP(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:15: ASSIGN
			{
			DebugLocation(1, 15);
			mASSIGN(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:22: PLUS
			{
			DebugLocation(1, 22);
			mPLUS(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:27: MINUS
			{
			DebugLocation(1, 27);
			mMINUS(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:33: MULTIPLY
			{
			DebugLocation(1, 33);
			mMULTIPLY(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:42: DIVIDE
			{
			DebugLocation(1, 42);
			mDIVIDE(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:49: LPAREN
			{
			DebugLocation(1, 49);
			mLPAREN(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:56: RPAREN
			{
			DebugLocation(1, 56);
			mRPAREN(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:63: EQUALS
			{
			DebugLocation(1, 63);
			mEQUALS(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:70: GT
			{
			DebugLocation(1, 70);
			mGT(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:73: LT
			{
			DebugLocation(1, 73);
			mLT(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:76: LTEQ
			{
			DebugLocation(1, 76);
			mLTEQ(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:81: GTEQ
			{
			DebugLocation(1, 81);
			mGTEQ(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:86: OR
			{
			DebugLocation(1, 86);
			mOR(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:89: AND
			{
			DebugLocation(1, 89);
			mAND(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:93: WHILE
			{
			DebugLocation(1, 93);
			mWHILE(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:99: DECLARE
			{
			DebugLocation(1, 99);
			mDECLARE(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:107: PROGRAM
			{
			DebugLocation(1, 107);
			mPROGRAM(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:115: FUNCTION
			{
			DebugLocation(1, 115);
			mFUNCTION(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:124: IF
			{
			DebugLocation(1, 124);
			mIF(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:127: RUN
			{
			DebugLocation(1, 127);
			mRUN(); 

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:131: THEN
			{
			DebugLocation(1, 131);
			mTHEN(); 

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:136: ELSE
			{
			DebugLocation(1, 136);
			mELSE(); 

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:141: CALL
			{
			DebugLocation(1, 141);
			mCALL(); 

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:146: RETURN
			{
			DebugLocation(1, 146);
			mRETURN(); 

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:153: LCURLY
			{
			DebugLocation(1, 153);
			mLCURLY(); 

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:160: RCURLY
			{
			DebugLocation(1, 160);
			mRCURLY(); 

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:167: SEMI
			{
			DebugLocation(1, 167);
			mSEMI(); 

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:172: WS
			{
			DebugLocation(1, 172);
			mWS(); 

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:175: COMMENT
			{
			DebugLocation(1, 175);
			mCOMMENT(); 

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:183: INT
			{
			DebugLocation(1, 183);
			mINT(); 

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:187: FLOAT
			{
			DebugLocation(1, 187);
			mFLOAT(); 

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:193: IDENTIFIER
			{
			DebugLocation(1, 193);
			mIDENTIFIER(); 

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:204: COMMA
			{
			DebugLocation(1, 204);
			mCOMMA(); 

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangLexer.g:1:210: COLON
			{
			DebugLocation(1, 210);
			mCOLON(); 

			}
			break;

		}

	}


	#region DFA
	DFA12 dfa12;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa12 = new DFA12(this);
	}

	private class DFA12 : DFA
	{
		private const string DFA12_eotS =
			"\x1\xFFFF\x1\x1B\x1\x20\x3\xFFFF\x1\x22\x4\xFFFF\x1\x26\xA\x1B\x4\xFFFF"+
			"\x1\x32\x2\xFFFF\x2\x1B\x8\xFFFF\x1\x36\x5\x1B\x1\x3C\x4\x1B\x2\xFFFF"+
			"\x1\x41\x1\x1B\x1\xFFFF\x1\x43\x4\x1B\x1\xFFFF\x1\x48\x3\x1B\x1\xFFFF"+
			"\x1\x4C\x1\xFFFF\x4\x1B\x1\xFFFF\x1\x1B\x1\x52\x1\x53\x1\xFFFF\x1\x54"+
			"\x4\x1B\x3\xFFFF\x3\x1B\x1\x5C\x1\x5D\x1\x5E\x1\x1B\x3\xFFFF\x1\x60\x1"+
			"\xFFFF";
		private const string DFA12_eofS =
			"\x61\xFFFF";
		private const string DFA12_minS =
			"\x1\x9\x1\x6C\x1\x3D\x3\xFFFF\x1\x2A\x2\xFFFF\x1\x3D\x1\xFFFF\x1\x3D"+
			"\x1\x52\x1\x4E\x1\x68\x1\x65\x1\x72\x1\x75\x1\x66\x1\x65\x1\x68\x1\x61"+
			"\x4\xFFFF\x1\x2E\x2\xFFFF\x1\x64\x1\x73\x8\xFFFF\x1\x30\x1\x44\x1\x69"+
			"\x1\x63\x1\x6F\x1\x6E\x1\x30\x1\x6E\x1\x74\x1\x65\x1\x6C\x2\xFFFF\x1"+
			"\x30\x1\x65\x1\xFFFF\x1\x30\x2\x6C\x1\x67\x1\x63\x1\xFFFF\x1\x30\x1\x75"+
			"\x1\x6E\x1\x6C\x1\xFFFF\x1\x30\x1\xFFFF\x1\x65\x1\x61\x1\x72\x1\x74\x1"+
			"\xFFFF\x1\x72\x2\x30\x1\xFFFF\x1\x30\x1\x72\x1\x61\x1\x69\x1\x6E\x3\xFFFF"+
			"\x1\x65\x1\x6D\x1\x6F\x3\x30\x1\x6E\x3\xFFFF\x1\x30\x1\xFFFF";
		private const string DFA12_maxS =
			"\x1\x7D\x1\x6E\x1\x3D\x3\xFFFF\x1\x2F\x2\xFFFF\x1\x3E\x1\xFFFF\x1\x3D"+
			"\x1\x52\x1\x4E\x1\x68\x1\x65\x1\x72\x1\x75\x1\x66\x1\x75\x1\x68\x1\x61"+
			"\x4\xFFFF\x1\x39\x2\xFFFF\x1\x64\x1\x73\x8\xFFFF\x1\x7A\x1\x44\x1\x69"+
			"\x1\x63\x1\x6F\x1\x6E\x1\x7A\x1\x6E\x1\x74\x1\x65\x1\x6C\x2\xFFFF\x1"+
			"\x7A\x1\x65\x1\xFFFF\x1\x7A\x2\x6C\x1\x67\x1\x63\x1\xFFFF\x1\x7A\x1\x75"+
			"\x1\x6E\x1\x6C\x1\xFFFF\x1\x7A\x1\xFFFF\x1\x65\x1\x61\x1\x72\x1\x74\x1"+
			"\xFFFF\x1\x72\x2\x7A\x1\xFFFF\x1\x7A\x1\x72\x1\x61\x1\x69\x1\x6E\x3\xFFFF"+
			"\x1\x65\x1\x6D\x1\x6F\x3\x7A\x1\x6E\x3\xFFFF\x1\x7A\x1\xFFFF";
		private const string DFA12_acceptS =
			"\x3\xFFFF\x1\x3\x1\x4\x1\x5\x1\xFFFF\x1\x7\x1\x8\x1\xFFFF\x1\xA\xB\xFFFF"+
			"\x1\x1A\x1\x1B\x1\x1C\x1\x1D\x1\xFFFF\x1\x21\x1\x22\x2\xFFFF\x1\x2\x1"+
			"\x23\x1\x1E\x1\x6\x1\x9\x1\xD\x1\xC\x1\xB\xB\xFFFF\x1\x1F\x1\x20\x2\xFFFF"+
			"\x1\xE\x5\xFFFF\x1\x14\x4\xFFFF\x1\x1\x1\xFFFF\x1\xF\x4\xFFFF\x1\x15"+
			"\x3\xFFFF\x1\x17\x5\xFFFF\x1\x16\x1\x18\x1\x10\x7\xFFFF\x1\x19\x1\x11"+
			"\x1\x12\x1\xFFFF\x1\x13";
		private const string DFA12_specialS =
			"\x61\xFFFF}>";
		private static readonly string[] DFA12_transitionS =
			{
				"\x2\x19\x1\xFFFF\x2\x19\x12\xFFFF\x1\x19\x7\xFFFF\x1\x7\x1\x8\x1\x5"+
				"\x1\x3\x1\x1C\x1\x4\x1\xFFFF\x1\x6\xA\x1A\x1\x2\x1\x18\x1\xB\x1\x9\x1"+
				"\xA\x2\xFFFF\x1\xD\xD\x1B\x1\xC\xB\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x2\x1B"+
				"\x1\x15\x1\xF\x1\x1\x1\x11\x2\x1B\x1\x12\x6\x1B\x1\x10\x1\x1B\x1\x13"+
				"\x1\x1B\x1\x14\x2\x1B\x1\xE\x3\x1B\x1\x16\x1\xFFFF\x1\x17",
				"\x1\x1E\x1\xFFFF\x1\x1D",
				"\x1\x1F",
				"",
				"",
				"",
				"\x1\x21\x4\xFFFF\x1\x21",
				"",
				"",
				"\x1\x23\x1\x24",
				"",
				"\x1\x25",
				"\x1\x27",
				"\x1\x28",
				"\x1\x29",
				"\x1\x2A",
				"\x1\x2B",
				"\x1\x2C",
				"\x1\x2D",
				"\x1\x2F\xF\xFFFF\x1\x2E",
				"\x1\x30",
				"\x1\x31",
				"",
				"",
				"",
				"",
				"\x1\x33\x1\xFFFF\xA\x1A",
				"",
				"",
				"\x1\x34",
				"\x1\x35",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"\x1\x37",
				"\x1\x38",
				"\x1\x39",
				"\x1\x3A",
				"\x1\x3B",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"\x1\x3D",
				"\x1\x3E",
				"\x1\x3F",
				"\x1\x40",
				"",
				"",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"\x1\x42",
				"",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"\x1\x44",
				"\x1\x45",
				"\x1\x46",
				"\x1\x47",
				"",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"\x1\x49",
				"\x1\x4A",
				"\x1\x4B",
				"",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"",
				"\x1\x4D",
				"\x1\x4E",
				"\x1\x4F",
				"\x1\x50",
				"",
				"\x1\x51",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"\x1\x55",
				"\x1\x56",
				"\x1\x57",
				"\x1\x58",
				"",
				"",
				"",
				"\x1\x59",
				"\x1\x5A",
				"\x1\x5B",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				"\x1\x5F",
				"",
				"",
				"",
				"\xA\x1B\x7\xFFFF\x1A\x1B\x4\xFFFF\x1\x1B\x1\xFFFF\x1A\x1B",
				""
			};

		private static readonly short[] DFA12_eot = DFA.UnpackEncodedString(DFA12_eotS);
		private static readonly short[] DFA12_eof = DFA.UnpackEncodedString(DFA12_eofS);
		private static readonly char[] DFA12_min = DFA.UnpackEncodedStringToUnsignedChars(DFA12_minS);
		private static readonly char[] DFA12_max = DFA.UnpackEncodedStringToUnsignedChars(DFA12_maxS);
		private static readonly short[] DFA12_accept = DFA.UnpackEncodedString(DFA12_acceptS);
		private static readonly short[] DFA12_special = DFA.UnpackEncodedString(DFA12_specialS);
		private static readonly short[][] DFA12_transition;

		static DFA12()
		{
			int numStates = DFA12_transitionS.Length;
			DFA12_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA12_transition[i] = DFA.UnpackEncodedString(DFA12_transitionS[i]);
			}
		}

		public DFA12( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 12;
			this.eot = DFA12_eot;
			this.eof = DFA12_eof;
			this.min = DFA12_min;
			this.max = DFA12_max;
			this.accept = DFA12_accept;
			this.special = DFA12_special;
			this.transition = DFA12_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( ENDP | ASSIGN | PLUS | MINUS | MULTIPLY | DIVIDE | LPAREN | RPAREN | EQUALS | GT | LT | LTEQ | GTEQ | OR | AND | WHILE | DECLARE | PROGRAM | FUNCTION | IF | RUN | THEN | ELSE | CALL | RETURN | LCURLY | RCURLY | SEMI | WS | COMMENT | INT | FLOAT | IDENTIFIER | COMMA | COLON );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

 
	#endregion

}

} // namespace  PlayingWithDLR.MyScriptRuntime.Script 
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g 2012-01-06 22:53:24

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  PlayingWithDLR.MyScriptRuntime.Script 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class MyLangParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ASSIGN", "BLOCKSTMT", "CALL", "COLON", "COMMA", "COMMENT", "DECLARE", "DIGIT", "DIVIDE", "DOT", "ELSE", "ENDP", "EQUALS", "EXPONENT", "FLOAT", "FUNCCALL", "FUNCDECL", "FUNCTION", "GT", "GTEQ", "IDENTIFIER", "IF", "INT", "LCLETTER", "LCURLY", "LPAREN", "LT", "LTEQ", "MINUS", "MULTIPLY", "NEGATE", "OR", "PLUS", "PROGDECL", "PROGRAM", "RCURLY", "RETURN", "RPAREN", "RUN", "RUNPROG", "SEMI", "THEN", "UCLETTER", "USCORE", "VAR", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int ASSIGN=5;
	public const int BLOCKSTMT=6;
	public const int CALL=7;
	public const int COLON=8;
	public const int COMMA=9;
	public const int COMMENT=10;
	public const int DECLARE=11;
	public const int DIGIT=12;
	public const int DIVIDE=13;
	public const int DOT=14;
	public const int ELSE=15;
	public const int ENDP=16;
	public const int EQUALS=17;
	public const int EXPONENT=18;
	public const int FLOAT=19;
	public const int FUNCCALL=20;
	public const int FUNCDECL=21;
	public const int FUNCTION=22;
	public const int GT=23;
	public const int GTEQ=24;
	public const int IDENTIFIER=25;
	public const int IF=26;
	public const int INT=27;
	public const int LCLETTER=28;
	public const int LCURLY=29;
	public const int LPAREN=30;
	public const int LT=31;
	public const int LTEQ=32;
	public const int MINUS=33;
	public const int MULTIPLY=34;
	public const int NEGATE=35;
	public const int OR=36;
	public const int PLUS=37;
	public const int PROGDECL=38;
	public const int PROGRAM=39;
	public const int RCURLY=40;
	public const int RETURN=41;
	public const int RPAREN=42;
	public const int RUN=43;
	public const int RUNPROG=44;
	public const int SEMI=45;
	public const int THEN=46;
	public const int UCLETTER=47;
	public const int USCORE=48;
	public const int VAR=49;
	public const int WHILE=50;
	public const int WS=51;

	public MyLangParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public MyLangParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return MyLangParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_runprogram();
	partial void LeaveRule_runprogram();

	// $ANTLR start "runprogram"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:26:8: public runprogram : ( WS )? RUN WS PROGRAM WS IDENTIFIER ( WS )? EOF -> ^( RUNPROG IDENTIFIER ) ;
	[GrammarRule("runprogram")]
	public AstParserRuleReturnScope<CommonTree, IToken> runprogram()
	{
		EnterRule_runprogram();
		EnterRule("runprogram", 1);
		TraceIn("runprogram", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WS1 = default(IToken);
		IToken RUN2 = default(IToken);
		IToken WS3 = default(IToken);
		IToken PROGRAM4 = default(IToken);
		IToken WS5 = default(IToken);
		IToken IDENTIFIER6 = default(IToken);
		IToken WS7 = default(IToken);
		IToken EOF8 = default(IToken);

		CommonTree WS1_tree = default(CommonTree);
		CommonTree RUN2_tree = default(CommonTree);
		CommonTree WS3_tree = default(CommonTree);
		CommonTree PROGRAM4_tree = default(CommonTree);
		CommonTree WS5_tree = default(CommonTree);
		CommonTree IDENTIFIER6_tree = default(CommonTree);
		CommonTree WS7_tree = default(CommonTree);
		CommonTree EOF8_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RUN=new RewriteRuleITokenStream(adaptor,"token RUN");
		RewriteRuleITokenStream stream_PROGRAM=new RewriteRuleITokenStream(adaptor,"token PROGRAM");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		try { DebugEnterRule(GrammarFileName, "runprogram");
		DebugLocation(26, 71);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:27:5: ( ( WS )? RUN WS PROGRAM WS IDENTIFIER ( WS )? EOF -> ^( RUNPROG IDENTIFIER ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:27:7: ( WS )? RUN WS PROGRAM WS IDENTIFIER ( WS )? EOF
			{
			DebugLocation(27, 7);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:27:7: ( WS )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==WS))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:27:7: WS
				{
				DebugLocation(27, 7);
				WS1=(IToken)Match(input,WS,Follow._WS_in_runprogram136); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS1);


				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(27, 11);
			RUN2=(IToken)Match(input,RUN,Follow._RUN_in_runprogram139); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RUN.Add(RUN2);

			DebugLocation(27, 15);
			WS3=(IToken)Match(input,WS,Follow._WS_in_runprogram141); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS3);

			DebugLocation(27, 18);
			PROGRAM4=(IToken)Match(input,PROGRAM,Follow._PROGRAM_in_runprogram143); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PROGRAM.Add(PROGRAM4);

			DebugLocation(27, 26);
			WS5=(IToken)Match(input,WS,Follow._WS_in_runprogram145); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS5);

			DebugLocation(27, 29);
			IDENTIFIER6=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_runprogram147); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER6);

			DebugLocation(27, 40);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:27:40: ( WS )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==WS))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:27:40: WS
				{
				DebugLocation(27, 40);
				WS7=(IToken)Match(input,WS,Follow._WS_in_runprogram149); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS7);


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(27, 44);
			EOF8=(IToken)Match(input,EOF,Follow._EOF_in_runprogram152); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF8);



			{
			// AST REWRITE
			// elements: IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 27:48: -> ^( RUNPROG IDENTIFIER )
			{
				DebugLocation(27, 51);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:27:51: ^( RUNPROG IDENTIFIER )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(27, 53);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(RUNPROG, "RUNPROG"), root_1);

				DebugLocation(27, 61);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("runprogram", 1);
			LeaveRule("runprogram", 1);
			LeaveRule_runprogram();
		}
		DebugLocation(27, 71);
		} finally { DebugExitRule(GrammarFileName, "runprogram"); }
		return retval;

	}
	// $ANTLR end "runprogram"

	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:29:8: public program : ( WS )? DECLARE WS PROGRAM ( WS )? COLON WS IDENTIFIER ( WS )? LCURLY ( WS )? ( funcdecl )* ( WS )? blockstatement ( WS )? RCURLY ( WS )? ( ( ENDP ) | EOF ) -> ^( PROGDECL IDENTIFIER ( funcdecl )* blockstatement ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 2);
		TraceIn("program", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WS9 = default(IToken);
		IToken DECLARE10 = default(IToken);
		IToken WS11 = default(IToken);
		IToken PROGRAM12 = default(IToken);
		IToken WS13 = default(IToken);
		IToken COLON14 = default(IToken);
		IToken WS15 = default(IToken);
		IToken IDENTIFIER16 = default(IToken);
		IToken WS17 = default(IToken);
		IToken LCURLY18 = default(IToken);
		IToken WS19 = default(IToken);
		IToken WS21 = default(IToken);
		IToken WS23 = default(IToken);
		IToken RCURLY24 = default(IToken);
		IToken WS25 = default(IToken);
		IToken ENDP26 = default(IToken);
		IToken EOF27 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> funcdecl20 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement22 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WS9_tree = default(CommonTree);
		CommonTree DECLARE10_tree = default(CommonTree);
		CommonTree WS11_tree = default(CommonTree);
		CommonTree PROGRAM12_tree = default(CommonTree);
		CommonTree WS13_tree = default(CommonTree);
		CommonTree COLON14_tree = default(CommonTree);
		CommonTree WS15_tree = default(CommonTree);
		CommonTree IDENTIFIER16_tree = default(CommonTree);
		CommonTree WS17_tree = default(CommonTree);
		CommonTree LCURLY18_tree = default(CommonTree);
		CommonTree WS19_tree = default(CommonTree);
		CommonTree WS21_tree = default(CommonTree);
		CommonTree WS23_tree = default(CommonTree);
		CommonTree RCURLY24_tree = default(CommonTree);
		CommonTree WS25_tree = default(CommonTree);
		CommonTree ENDP26_tree = default(CommonTree);
		CommonTree EOF27_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ENDP=new RewriteRuleITokenStream(adaptor,"token ENDP");
		RewriteRuleITokenStream stream_DECLARE=new RewriteRuleITokenStream(adaptor,"token DECLARE");
		RewriteRuleITokenStream stream_PROGRAM=new RewriteRuleITokenStream(adaptor,"token PROGRAM");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_blockstatement=new RewriteRuleSubtreeStream(adaptor,"rule blockstatement");
		RewriteRuleSubtreeStream stream_funcdecl=new RewriteRuleSubtreeStream(adaptor,"rule funcdecl");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(29, 178);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:30:5: ( ( WS )? DECLARE WS PROGRAM ( WS )? COLON WS IDENTIFIER ( WS )? LCURLY ( WS )? ( funcdecl )* ( WS )? blockstatement ( WS )? RCURLY ( WS )? ( ( ENDP ) | EOF ) -> ^( PROGDECL IDENTIFIER ( funcdecl )* blockstatement ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:7: ( WS )? DECLARE WS PROGRAM ( WS )? COLON WS IDENTIFIER ( WS )? LCURLY ( WS )? ( funcdecl )* ( WS )? blockstatement ( WS )? RCURLY ( WS )? ( ( ENDP ) | EOF )
			{
			DebugLocation(31, 7);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:7: ( WS )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==WS))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:7: WS
				{
				DebugLocation(31, 7);
				WS9=(IToken)Match(input,WS,Follow._WS_in_program181); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS9);


				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(31, 11);
			DECLARE10=(IToken)Match(input,DECLARE,Follow._DECLARE_in_program184); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DECLARE.Add(DECLARE10);

			DebugLocation(31, 19);
			WS11=(IToken)Match(input,WS,Follow._WS_in_program186); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS11);

			DebugLocation(31, 22);
			PROGRAM12=(IToken)Match(input,PROGRAM,Follow._PROGRAM_in_program188); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PROGRAM.Add(PROGRAM12);

			DebugLocation(31, 30);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:30: ( WS )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==WS))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:30: WS
				{
				DebugLocation(31, 30);
				WS13=(IToken)Match(input,WS,Follow._WS_in_program190); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS13);


				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(31, 34);
			COLON14=(IToken)Match(input,COLON,Follow._COLON_in_program193); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON14);

			DebugLocation(31, 40);
			WS15=(IToken)Match(input,WS,Follow._WS_in_program195); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS15);

			DebugLocation(31, 43);
			IDENTIFIER16=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_program197); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER16);

			DebugLocation(31, 54);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:54: ( WS )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==WS))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:54: WS
				{
				DebugLocation(31, 54);
				WS17=(IToken)Match(input,WS,Follow._WS_in_program199); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS17);


				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(31, 58);
			LCURLY18=(IToken)Match(input,LCURLY,Follow._LCURLY_in_program202); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY18);

			DebugLocation(31, 65);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:65: ( WS )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==WS))
			{
				int LA6_1 = input.LA(2);

				if ((EvaluatePredicate(synpred6_MyLangParser_fragment)))
				{
					alt6 = 1;
				}
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:65: WS
				{
				DebugLocation(31, 65);
				WS19=(IToken)Match(input,WS,Follow._WS_in_program204); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS19);


				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(31, 69);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:69: ( funcdecl )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==DECLARE))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:69: funcdecl
					{
					DebugLocation(31, 69);
					PushFollow(Follow._funcdecl_in_program207);
					funcdecl20=funcdecl();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_funcdecl.Add(funcdecl20.Tree);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(31, 79);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:79: ( WS )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==WS))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:79: WS
				{
				DebugLocation(31, 79);
				WS21=(IToken)Match(input,WS,Follow._WS_in_program210); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS21);


				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(31, 83);
			PushFollow(Follow._blockstatement_in_program213);
			blockstatement22=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_blockstatement.Add(blockstatement22.Tree);
			DebugLocation(31, 98);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:98: ( WS )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==WS))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:98: WS
				{
				DebugLocation(31, 98);
				WS23=(IToken)Match(input,WS,Follow._WS_in_program215); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS23);


				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(31, 102);
			RCURLY24=(IToken)Match(input,RCURLY,Follow._RCURLY_in_program218); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY24);

			DebugLocation(31, 109);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:109: ( WS )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==WS))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:109: WS
				{
				DebugLocation(31, 109);
				WS25=(IToken)Match(input,WS,Follow._WS_in_program220); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS25);


				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(31, 113);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:113: ( ( ENDP ) | EOF )
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==ENDP))
			{
				alt11 = 1;
			}
			else if ((LA11_0==EOF))
			{
				alt11 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:114: ( ENDP )
				{
				DebugLocation(31, 114);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:114: ( ENDP )
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:115: ENDP
				{
				DebugLocation(31, 115);
				ENDP26=(IToken)Match(input,ENDP,Follow._ENDP_in_program225); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ENDP.Add(ENDP26);


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:124: EOF
				{
				DebugLocation(31, 124);
				EOF27=(IToken)Match(input,EOF,Follow._EOF_in_program231); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_EOF.Add(EOF27);


				}
				break;

			}
			} finally { DebugExitSubRule(11); }



			{
			// AST REWRITE
			// elements: funcdecl, blockstatement, IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 31:129: -> ^( PROGDECL IDENTIFIER ( funcdecl )* blockstatement )
			{
				DebugLocation(31, 132);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:132: ^( PROGDECL IDENTIFIER ( funcdecl )* blockstatement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(31, 134);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROGDECL, "PROGDECL"), root_1);

				DebugLocation(31, 143);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(31, 154);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:154: ( funcdecl )*
				while ( stream_funcdecl.HasNext )
				{
					DebugLocation(31, 154);
					adaptor.AddChild(root_1, stream_funcdecl.NextTree());

				}
				stream_funcdecl.Reset();
				DebugLocation(31, 164);
				adaptor.AddChild(root_1, stream_blockstatement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 2);
			LeaveRule("program", 2);
			LeaveRule_program();
		}
		DebugLocation(31, 178);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_blockstatement();
	partial void LeaveRule_blockstatement();

	// $ANTLR start "blockstatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:33:1: blockstatement : LCURLY ( statement )* RCURLY -> ^( BLOCKSTMT ( statement )* ) ;
	[GrammarRule("blockstatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> blockstatement()
	{
		EnterRule_blockstatement();
		EnterRule("blockstatement", 3);
		TraceIn("blockstatement", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LCURLY28 = default(IToken);
		IToken RCURLY30 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement29 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LCURLY28_tree = default(CommonTree);
		CommonTree RCURLY30_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "blockstatement");
		DebugLocation(33, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:34:5: ( LCURLY ( statement )* RCURLY -> ^( BLOCKSTMT ( statement )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:34:7: LCURLY ( statement )* RCURLY
			{
			DebugLocation(34, 7);
			LCURLY28=(IToken)Match(input,LCURLY,Follow._LCURLY_in_blockstatement258); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY28);

			DebugLocation(34, 14);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:34:14: ( statement )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if (((LA12_0>=IDENTIFIER && LA12_0<=IF)||LA12_0==LCURLY||LA12_0==RETURN||LA12_0==WHILE))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:34:14: statement
					{
					DebugLocation(34, 14);
					PushFollow(Follow._statement_in_blockstatement260);
					statement29=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement29.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(34, 25);
			RCURLY30=(IToken)Match(input,RCURLY,Follow._RCURLY_in_blockstatement263); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY30);



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 34:32: -> ^( BLOCKSTMT ( statement )* )
			{
				DebugLocation(34, 35);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:34:35: ^( BLOCKSTMT ( statement )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(34, 37);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BLOCKSTMT, "BLOCKSTMT"), root_1);

				DebugLocation(34, 47);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:34:47: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(34, 47);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("blockstatement", 3);
			LeaveRule("blockstatement", 3);
			LeaveRule_blockstatement();
		}
		DebugLocation(35, 4);
		} finally { DebugExitRule(GrammarFileName, "blockstatement"); }
		return retval;

	}
	// $ANTLR end "blockstatement"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();

	// $ANTLR start "assignment"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:37:1: assignment : IDENTIFIER ASSIGN expression -> ^( ASSIGN IDENTIFIER expression ) ;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 4);
		TraceIn("assignment", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENTIFIER31 = default(IToken);
		IToken ASSIGN32 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression33 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENTIFIER31_tree = default(CommonTree);
		CommonTree ASSIGN32_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(37, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:38:5: ( IDENTIFIER ASSIGN expression -> ^( ASSIGN IDENTIFIER expression ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:39:5: IDENTIFIER ASSIGN expression
			{
			DebugLocation(39, 5);
			IDENTIFIER31=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_assignment294); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER31);

			DebugLocation(39, 16);
			ASSIGN32=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_assignment296); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN32);

			DebugLocation(39, 23);
			PushFollow(Follow._expression_in_assignment298);
			expression33=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression33.Tree);


			{
			// AST REWRITE
			// elements: expression, IDENTIFIER, ASSIGN
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 39:34: -> ^( ASSIGN IDENTIFIER expression )
			{
				DebugLocation(39, 37);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:39:37: ^( ASSIGN IDENTIFIER expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(39, 39);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

				DebugLocation(39, 46);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(39, 57);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 4);
			LeaveRule("assignment", 4);
			LeaveRule_assignment();
		}
		DebugLocation(40, 4);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_ifstatement();
	partial void LeaveRule_ifstatement();

	// $ANTLR start "ifstatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:42:1: ifstatement : IF LPAREN ! expression RPAREN ! THEN ! blockstatement ( ELSE ! blockstatement ) ;
	[GrammarRule("ifstatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> ifstatement()
	{
		EnterRule_ifstatement();
		EnterRule("ifstatement", 5);
		TraceIn("ifstatement", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IF34 = default(IToken);
		IToken LPAREN35 = default(IToken);
		IToken RPAREN37 = default(IToken);
		IToken THEN38 = default(IToken);
		IToken ELSE40 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression36 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement39 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement41 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IF34_tree = default(CommonTree);
		CommonTree LPAREN35_tree = default(CommonTree);
		CommonTree RPAREN37_tree = default(CommonTree);
		CommonTree THEN38_tree = default(CommonTree);
		CommonTree ELSE40_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "ifstatement");
		DebugLocation(42, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:43:5: ( IF LPAREN ! expression RPAREN ! THEN ! blockstatement ( ELSE ! blockstatement ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:44:5: IF LPAREN ! expression RPAREN ! THEN ! blockstatement ( ELSE ! blockstatement )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(44, 5);
			IF34=(IToken)Match(input,IF,Follow._IF_in_ifstatement332); if (state.failed) return retval;
			if (state.backtracking == 0) {
			IF34_tree = (CommonTree)adaptor.Create(IF34);
			adaptor.AddChild(root_0, IF34_tree);
			}
			DebugLocation(44, 14);
			LPAREN35=(IToken)Match(input,LPAREN,Follow._LPAREN_in_ifstatement334); if (state.failed) return retval;
			DebugLocation(44, 16);
			PushFollow(Follow._expression_in_ifstatement337);
			expression36=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression36.Tree);
			DebugLocation(44, 33);
			RPAREN37=(IToken)Match(input,RPAREN,Follow._RPAREN_in_ifstatement339); if (state.failed) return retval;
			DebugLocation(44, 39);
			THEN38=(IToken)Match(input,THEN,Follow._THEN_in_ifstatement342); if (state.failed) return retval;
			DebugLocation(45, 9);
			PushFollow(Follow._blockstatement_in_ifstatement354);
			blockstatement39=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement39.Tree);
			DebugLocation(46, 5);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:46:5: ( ELSE ! blockstatement )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:47:9: ELSE ! blockstatement
			{
			DebugLocation(47, 13);
			ELSE40=(IToken)Match(input,ELSE,Follow._ELSE_in_ifstatement371); if (state.failed) return retval;
			DebugLocation(48, 9);
			PushFollow(Follow._blockstatement_in_ifstatement383);
			blockstatement41=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement41.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifstatement", 5);
			LeaveRule("ifstatement", 5);
			LeaveRule_ifstatement();
		}
		DebugLocation(50, 4);
		} finally { DebugExitRule(GrammarFileName, "ifstatement"); }
		return retval;

	}
	// $ANTLR end "ifstatement"

	partial void EnterRule_whilestatement();
	partial void LeaveRule_whilestatement();

	// $ANTLR start "whilestatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:52:1: whilestatement : WHILE LPAREN ! expression RPAREN ! blockstatement ;
	[GrammarRule("whilestatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> whilestatement()
	{
		EnterRule_whilestatement();
		EnterRule("whilestatement", 6);
		TraceIn("whilestatement", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WHILE42 = default(IToken);
		IToken LPAREN43 = default(IToken);
		IToken RPAREN45 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression44 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement46 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WHILE42_tree = default(CommonTree);
		CommonTree LPAREN43_tree = default(CommonTree);
		CommonTree RPAREN45_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "whilestatement");
		DebugLocation(52, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:53:5: ( WHILE LPAREN ! expression RPAREN ! blockstatement )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:54:5: WHILE LPAREN ! expression RPAREN ! blockstatement
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(54, 5);
			WHILE42=(IToken)Match(input,WHILE,Follow._WHILE_in_whilestatement412); if (state.failed) return retval;
			if (state.backtracking == 0) {
			WHILE42_tree = (CommonTree)adaptor.Create(WHILE42);
			adaptor.AddChild(root_0, WHILE42_tree);
			}
			DebugLocation(54, 17);
			LPAREN43=(IToken)Match(input,LPAREN,Follow._LPAREN_in_whilestatement414); if (state.failed) return retval;
			DebugLocation(54, 19);
			PushFollow(Follow._expression_in_whilestatement417);
			expression44=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression44.Tree);
			DebugLocation(54, 36);
			RPAREN45=(IToken)Match(input,RPAREN,Follow._RPAREN_in_whilestatement419); if (state.failed) return retval;
			DebugLocation(54, 38);
			PushFollow(Follow._blockstatement_in_whilestatement422);
			blockstatement46=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement46.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whilestatement", 6);
			LeaveRule("whilestatement", 6);
			LeaveRule_whilestatement();
		}
		DebugLocation(55, 4);
		} finally { DebugExitRule(GrammarFileName, "whilestatement"); }
		return retval;

	}
	// $ANTLR end "whilestatement"

	partial void EnterRule_returnstatement();
	partial void LeaveRule_returnstatement();

	// $ANTLR start "returnstatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:57:1: returnstatement : RETURN expression ;
	[GrammarRule("returnstatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> returnstatement()
	{
		EnterRule_returnstatement();
		EnterRule("returnstatement", 7);
		TraceIn("returnstatement", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken RETURN47 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression48 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree RETURN47_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "returnstatement");
		DebugLocation(57, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:58:5: ( RETURN expression )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:58:7: RETURN expression
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(58, 7);
			RETURN47=(IToken)Match(input,RETURN,Follow._RETURN_in_returnstatement439); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RETURN47_tree = (CommonTree)adaptor.Create(RETURN47);
			adaptor.AddChild(root_0, RETURN47_tree);
			}
			DebugLocation(58, 14);
			PushFollow(Follow._expression_in_returnstatement441);
			expression48=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression48.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("returnstatement", 7);
			LeaveRule("returnstatement", 7);
			LeaveRule_returnstatement();
		}
		DebugLocation(59, 4);
		} finally { DebugExitRule(GrammarFileName, "returnstatement"); }
		return retval;

	}
	// $ANTLR end "returnstatement"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:61:1: statement : ( assignment | ifstatement | returnstatement | whilestatement | blockstatement ) SEMI !;
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 8);
		TraceIn("statement", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken SEMI54 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignment49 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifstatement50 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> returnstatement51 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> whilestatement52 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement53 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI54_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(61, 9);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:62:5: ( ( assignment | ifstatement | returnstatement | whilestatement | blockstatement ) SEMI !)
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:63:5: ( assignment | ifstatement | returnstatement | whilestatement | blockstatement ) SEMI !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(63, 5);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:63:5: ( assignment | ifstatement | returnstatement | whilestatement | blockstatement )
			int alt13=5;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			switch (input.LA(1))
			{
			case IDENTIFIER:
				{
				alt13 = 1;
				}
				break;
			case IF:
				{
				alt13 = 2;
				}
				break;
			case RETURN:
				{
				alt13 = 3;
				}
				break;
			case WHILE:
				{
				alt13 = 4;
				}
				break;
			case LCURLY:
				{
				alt13 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:64:7: assignment
				{
				DebugLocation(64, 7);
				PushFollow(Follow._assignment_in_statement474);
				assignment49=assignment();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignment49.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:65:7: ifstatement
				{
				DebugLocation(65, 7);
				PushFollow(Follow._ifstatement_in_statement483);
				ifstatement50=ifstatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifstatement50.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:66:7: returnstatement
				{
				DebugLocation(66, 7);
				PushFollow(Follow._returnstatement_in_statement491);
				returnstatement51=returnstatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, returnstatement51.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:67:7: whilestatement
				{
				DebugLocation(67, 7);
				PushFollow(Follow._whilestatement_in_statement499);
				whilestatement52=whilestatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, whilestatement52.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:68:7: blockstatement
				{
				DebugLocation(68, 7);
				PushFollow(Follow._blockstatement_in_statement507);
				blockstatement53=blockstatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement53.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(70, 9);
			SEMI54=(IToken)Match(input,SEMI,Follow._SEMI_in_statement527); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 8);
			LeaveRule("statement", 8);
			LeaveRule_statement();
		}
		DebugLocation(70, 9);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_funcdecl();
	partial void LeaveRule_funcdecl();

	// $ANTLR start "funcdecl"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:72:1: funcdecl : DECLARE FUNCTION COLON IDENTIFIER LPAREN ( IDENTIFIER ( COMMA IDENTIFIER )* )? RPAREN blockstatement -> ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement ) ;
	[GrammarRule("funcdecl")]
	private AstParserRuleReturnScope<CommonTree, IToken> funcdecl()
	{
		EnterRule_funcdecl();
		EnterRule("funcdecl", 9);
		TraceIn("funcdecl", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DECLARE55 = default(IToken);
		IToken FUNCTION56 = default(IToken);
		IToken COLON57 = default(IToken);
		IToken IDENTIFIER58 = default(IToken);
		IToken LPAREN59 = default(IToken);
		IToken IDENTIFIER60 = default(IToken);
		IToken COMMA61 = default(IToken);
		IToken IDENTIFIER62 = default(IToken);
		IToken RPAREN63 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement64 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DECLARE55_tree = default(CommonTree);
		CommonTree FUNCTION56_tree = default(CommonTree);
		CommonTree COLON57_tree = default(CommonTree);
		CommonTree IDENTIFIER58_tree = default(CommonTree);
		CommonTree LPAREN59_tree = default(CommonTree);
		CommonTree IDENTIFIER60_tree = default(CommonTree);
		CommonTree COMMA61_tree = default(CommonTree);
		CommonTree IDENTIFIER62_tree = default(CommonTree);
		CommonTree RPAREN63_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_DECLARE=new RewriteRuleITokenStream(adaptor,"token DECLARE");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_blockstatement=new RewriteRuleSubtreeStream(adaptor,"rule blockstatement");
		try { DebugEnterRule(GrammarFileName, "funcdecl");
		DebugLocation(72, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:73:5: ( DECLARE FUNCTION COLON IDENTIFIER LPAREN ( IDENTIFIER ( COMMA IDENTIFIER )* )? RPAREN blockstatement -> ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:74:5: DECLARE FUNCTION COLON IDENTIFIER LPAREN ( IDENTIFIER ( COMMA IDENTIFIER )* )? RPAREN blockstatement
			{
			DebugLocation(74, 5);
			DECLARE55=(IToken)Match(input,DECLARE,Follow._DECLARE_in_funcdecl546); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DECLARE.Add(DECLARE55);

			DebugLocation(74, 13);
			FUNCTION56=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_funcdecl548); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION56);

			DebugLocation(74, 22);
			COLON57=(IToken)Match(input,COLON,Follow._COLON_in_funcdecl550); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON57);

			DebugLocation(74, 28);
			IDENTIFIER58=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl552); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER58);

			DebugLocation(74, 39);
			LPAREN59=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funcdecl554); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN59);

			DebugLocation(74, 46);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:74:46: ( IDENTIFIER ( COMMA IDENTIFIER )* )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==IDENTIFIER))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:74:47: IDENTIFIER ( COMMA IDENTIFIER )*
				{
				DebugLocation(74, 47);
				IDENTIFIER60=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl557); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER60);

				DebugLocation(74, 58);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:74:58: ( COMMA IDENTIFIER )*
				try { DebugEnterSubRule(14);
				while (true)
				{
					int alt14=2;
					try { DebugEnterDecision(14, false);
					int LA14_0 = input.LA(1);

					if ((LA14_0==COMMA))
					{
						alt14 = 1;
					}


					} finally { DebugExitDecision(14); }
					switch ( alt14 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:74:59: COMMA IDENTIFIER
						{
						DebugLocation(74, 59);
						COMMA61=(IToken)Match(input,COMMA,Follow._COMMA_in_funcdecl560); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA61);

						DebugLocation(74, 65);
						IDENTIFIER62=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl562); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER62);


						}
						break;

					default:
						goto loop14;
					}
				}

				loop14:
					;

				} finally { DebugExitSubRule(14); }


				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(74, 80);
			RPAREN63=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funcdecl568); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN63);

			DebugLocation(74, 87);
			PushFollow(Follow._blockstatement_in_funcdecl570);
			blockstatement64=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_blockstatement.Add(blockstatement64.Tree);


			{
			// AST REWRITE
			// elements: blockstatement, IDENTIFIER, IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 74:102: -> ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement )
			{
				DebugLocation(74, 105);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:74:105: ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(74, 107);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNCDECL, "FUNCDECL"), root_1);

				DebugLocation(74, 116);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(74, 127);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:74:127: ( IDENTIFIER )*
				while ( stream_IDENTIFIER.HasNext )
				{
					DebugLocation(74, 127);
					adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());

				}
				stream_IDENTIFIER.Reset();
				DebugLocation(74, 139);
				adaptor.AddChild(root_1, stream_blockstatement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcdecl", 9);
			LeaveRule("funcdecl", 9);
			LeaveRule_funcdecl();
		}
		DebugLocation(75, 4);
		} finally { DebugExitRule(GrammarFileName, "funcdecl"); }
		return retval;

	}
	// $ANTLR end "funcdecl"

	partial void EnterRule_funccall();
	partial void LeaveRule_funccall();

	// $ANTLR start "funccall"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:77:1: funccall : CALL IDENTIFIER LPAREN ( expression ( COMMA expression )* )? RPAREN -> ^( CALL IDENTIFIER ( expression )* ) ;
	[GrammarRule("funccall")]
	private AstParserRuleReturnScope<CommonTree, IToken> funccall()
	{
		EnterRule_funccall();
		EnterRule("funccall", 10);
		TraceIn("funccall", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken CALL65 = default(IToken);
		IToken IDENTIFIER66 = default(IToken);
		IToken LPAREN67 = default(IToken);
		IToken COMMA69 = default(IToken);
		IToken RPAREN71 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression68 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression70 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CALL65_tree = default(CommonTree);
		CommonTree IDENTIFIER66_tree = default(CommonTree);
		CommonTree LPAREN67_tree = default(CommonTree);
		CommonTree COMMA69_tree = default(CommonTree);
		CommonTree RPAREN71_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_CALL=new RewriteRuleITokenStream(adaptor,"token CALL");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "funccall");
		DebugLocation(77, 97);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:78:5: ( CALL IDENTIFIER LPAREN ( expression ( COMMA expression )* )? RPAREN -> ^( CALL IDENTIFIER ( expression )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:79:1: CALL IDENTIFIER LPAREN ( expression ( COMMA expression )* )? RPAREN
			{
			DebugLocation(79, 1);
			CALL65=(IToken)Match(input,CALL,Follow._CALL_in_funccall602); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CALL.Add(CALL65);

			DebugLocation(79, 6);
			IDENTIFIER66=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funccall604); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER66);

			DebugLocation(79, 17);
			LPAREN67=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funccall606); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN67);

			DebugLocation(79, 24);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:79:24: ( expression ( COMMA expression )* )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if ((LA17_0==CALL||LA17_0==FLOAT||LA17_0==IDENTIFIER||LA17_0==INT||LA17_0==LPAREN||LA17_0==NEGATE))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:79:25: expression ( COMMA expression )*
				{
				DebugLocation(79, 25);
				PushFollow(Follow._expression_in_funccall609);
				expression68=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression68.Tree);
				DebugLocation(79, 36);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:79:36: ( COMMA expression )*
				try { DebugEnterSubRule(16);
				while (true)
				{
					int alt16=2;
					try { DebugEnterDecision(16, false);
					int LA16_0 = input.LA(1);

					if ((LA16_0==COMMA))
					{
						alt16 = 1;
					}


					} finally { DebugExitDecision(16); }
					switch ( alt16 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:79:37: COMMA expression
						{
						DebugLocation(79, 37);
						COMMA69=(IToken)Match(input,COMMA,Follow._COMMA_in_funccall612); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA69);

						DebugLocation(79, 43);
						PushFollow(Follow._expression_in_funccall614);
						expression70=expression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expression.Add(expression70.Tree);

						}
						break;

					default:
						goto loop16;
					}
				}

				loop16:
					;

				} finally { DebugExitSubRule(16); }


				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(79, 58);
			RPAREN71=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funccall620); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN71);



			{
			// AST REWRITE
			// elements: expression, CALL, IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 79:65: -> ^( CALL IDENTIFIER ( expression )* )
			{
				DebugLocation(79, 68);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:79:68: ^( CALL IDENTIFIER ( expression )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(79, 70);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_CALL.NextNode(), root_1);

				DebugLocation(79, 75);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(79, 86);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:79:86: ( expression )*
				while ( stream_expression.HasNext )
				{
					DebugLocation(79, 86);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funccall", 10);
			LeaveRule("funccall", 10);
			LeaveRule_funccall();
		}
		DebugLocation(79, 97);
		} finally { DebugExitRule(GrammarFileName, "funccall"); }
		return retval;

	}
	// $ANTLR end "funccall"

	partial void EnterRule_primary();
	partial void LeaveRule_primary();

	// $ANTLR start "primary"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:82:1: primary : ( INT | FLOAT | IDENTIFIER -> ^( VAR IDENTIFIER ) | funccall | LPAREN ! expression RPAREN !);
	[GrammarRule("primary")]
	private AstParserRuleReturnScope<CommonTree, IToken> primary()
	{
		EnterRule_primary();
		EnterRule("primary", 11);
		TraceIn("primary", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INT72 = default(IToken);
		IToken FLOAT73 = default(IToken);
		IToken IDENTIFIER74 = default(IToken);
		IToken LPAREN76 = default(IToken);
		IToken RPAREN78 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> funccall75 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression77 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INT72_tree = default(CommonTree);
		CommonTree FLOAT73_tree = default(CommonTree);
		CommonTree IDENTIFIER74_tree = default(CommonTree);
		CommonTree LPAREN76_tree = default(CommonTree);
		CommonTree RPAREN78_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		try { DebugEnterRule(GrammarFileName, "primary");
		DebugLocation(82, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:83:5: ( INT | FLOAT | IDENTIFIER -> ^( VAR IDENTIFIER ) | funccall | LPAREN ! expression RPAREN !)
			int alt18=5;
			try { DebugEnterDecision(18, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt18 = 1;
				}
				break;
			case FLOAT:
				{
				alt18 = 2;
				}
				break;
			case IDENTIFIER:
				{
				alt18 = 3;
				}
				break;
			case CALL:
				{
				alt18 = 4;
				}
				break;
			case LPAREN:
				{
				alt18 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 18, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:83:7: INT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(83, 7);
				INT72=(IToken)Match(input,INT,Follow._INT_in_primary653); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INT72_tree = (CommonTree)adaptor.Create(INT72);
				adaptor.AddChild(root_0, INT72_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:84:7: FLOAT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(84, 7);
				FLOAT73=(IToken)Match(input,FLOAT,Follow._FLOAT_in_primary662); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FLOAT73_tree = (CommonTree)adaptor.Create(FLOAT73);
				adaptor.AddChild(root_0, FLOAT73_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:85:7: IDENTIFIER
				{
				DebugLocation(85, 7);
				IDENTIFIER74=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_primary670); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER74);



				{
				// AST REWRITE
				// elements: IDENTIFIER
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 85:18: -> ^( VAR IDENTIFIER )
				{
					DebugLocation(85, 21);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:85:21: ^( VAR IDENTIFIER )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(85, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VAR, "VAR"), root_1);

					DebugLocation(85, 27);
					adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:86:7: funccall
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(86, 7);
				PushFollow(Follow._funccall_in_primary686);
				funccall75=funccall();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funccall75.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:87:7: LPAREN ! expression RPAREN !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(87, 13);
				LPAREN76=(IToken)Match(input,LPAREN,Follow._LPAREN_in_primary694); if (state.failed) return retval;
				DebugLocation(87, 15);
				PushFollow(Follow._expression_in_primary697);
				expression77=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression77.Tree);
				DebugLocation(87, 32);
				RPAREN78=(IToken)Match(input,RPAREN,Follow._RPAREN_in_primary699); if (state.failed) return retval;

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primary", 11);
			LeaveRule("primary", 11);
			LeaveRule_primary();
		}
		DebugLocation(88, 4);
		} finally { DebugExitRule(GrammarFileName, "primary"); }
		return retval;

	}
	// $ANTLR end "primary"

	partial void EnterRule_unaryexpr();
	partial void LeaveRule_unaryexpr();

	// $ANTLR start "unaryexpr"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:90:1: unaryexpr : ( NEGATE )* primary ;
	[GrammarRule("unaryexpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> unaryexpr()
	{
		EnterRule_unaryexpr();
		EnterRule("unaryexpr", 12);
		TraceIn("unaryexpr", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NEGATE79 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> primary80 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NEGATE79_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unaryexpr");
		DebugLocation(90, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:91:5: ( ( NEGATE )* primary )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:91:7: ( NEGATE )* primary
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(91, 7);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:91:7: ( NEGATE )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==NEGATE))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:91:8: NEGATE
					{
					DebugLocation(91, 8);
					NEGATE79=(IToken)Match(input,NEGATE,Follow._NEGATE_in_unaryexpr718); if (state.failed) return retval;
					if (state.backtracking == 0) {
					NEGATE79_tree = (CommonTree)adaptor.Create(NEGATE79);
					adaptor.AddChild(root_0, NEGATE79_tree);
					}

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(91, 17);
			PushFollow(Follow._primary_in_unaryexpr722);
			primary80=primary();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primary80.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryexpr", 12);
			LeaveRule("unaryexpr", 12);
			LeaveRule_unaryexpr();
		}
		DebugLocation(92, 4);
		} finally { DebugExitRule(GrammarFileName, "unaryexpr"); }
		return retval;

	}
	// $ANTLR end "unaryexpr"

	partial void EnterRule_multexpr();
	partial void LeaveRule_multexpr();

	// $ANTLR start "multexpr"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:94:1: multexpr : unaryexpr ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )* ;
	[GrammarRule("multexpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> multexpr()
	{
		EnterRule_multexpr();
		EnterRule("multexpr", 13);
		TraceIn("multexpr", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set82 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unaryexpr81 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryexpr83 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set82_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multexpr");
		DebugLocation(94, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:95:5: ( unaryexpr ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )* )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:95:7: unaryexpr ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(95, 7);
			PushFollow(Follow._unaryexpr_in_multexpr749);
			unaryexpr81=unaryexpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, unaryexpr81.Tree);
			DebugLocation(95, 17);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:95:17: ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==DIVIDE||LA20_0==MULTIPLY))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:95:18: ( MULTIPLY | DIVIDE ) ^ unaryexpr
					{
					DebugLocation(95, 35);

					set82=(IToken)input.LT(1);
					set82=(IToken)input.LT(1);
					if (input.LA(1)==DIVIDE||input.LA(1)==MULTIPLY)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set82), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(95, 37);
					PushFollow(Follow._unaryexpr_in_multexpr759);
					unaryexpr83=unaryexpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, unaryexpr83.Tree);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multexpr", 13);
			LeaveRule("multexpr", 13);
			LeaveRule_multexpr();
		}
		DebugLocation(96, 4);
		} finally { DebugExitRule(GrammarFileName, "multexpr"); }
		return retval;

	}
	// $ANTLR end "multexpr"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:99:1: expression : multexpr ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 14);
		TraceIn("expression", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set85 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> multexpr84 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> multexpr86 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set85_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(99, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:100:5: ( multexpr ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )* )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:100:7: multexpr ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(100, 7);
			PushFollow(Follow._multexpr_in_expression784);
			multexpr84=multexpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, multexpr84.Tree);
			DebugLocation(100, 16);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:100:16: ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==AND||LA21_0==EQUALS||(LA21_0>=GT && LA21_0<=GTEQ)||(LA21_0>=LT && LA21_0<=MINUS)||(LA21_0>=OR && LA21_0<=PLUS)))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:100:17: ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr
					{
					DebugLocation(100, 59);

					set85=(IToken)input.LT(1);
					set85=(IToken)input.LT(1);
					if (input.LA(1)==AND||input.LA(1)==EQUALS||(input.LA(1)>=GT && input.LA(1)<=GTEQ)||(input.LA(1)>=LT && input.LA(1)<=MINUS)||(input.LA(1)>=OR && input.LA(1)<=PLUS))
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set85), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(100, 61);
					PushFollow(Follow._multexpr_in_expression808);
					multexpr86=multexpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multexpr86.Tree);

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 14);
			LeaveRule("expression", 14);
			LeaveRule_expression();
		}
		DebugLocation(101, 4);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_synpred6_MyLangParser_fragment();
	partial void LeaveRule_synpred6_MyLangParser_fragment();

	// $ANTLR start synpred6_MyLangParser
	public void synpred6_MyLangParser_fragment()
	{
		EnterRule_synpred6_MyLangParser_fragment();
		EnterRule("synpred6_MyLangParser_fragment", 20);
		TraceIn("synpred6_MyLangParser_fragment", 20);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:65: ( WS )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:31:65: WS
			{
			DebugLocation(31, 65);
			Match(input,WS,Follow._WS_in_synpred6_MyLangParser204); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred6_MyLangParser_fragment", 20);
			LeaveRule("synpred6_MyLangParser_fragment", 20);
			LeaveRule_synpred6_MyLangParser_fragment();
		}
	}
	// $ANTLR end synpred6_MyLangParser
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _WS_in_runprogram136 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _RUN_in_runprogram139 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_runprogram141 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _PROGRAM_in_runprogram143 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_runprogram145 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_runprogram147 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_runprogram149 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_runprogram152 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WS_in_program181 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _DECLARE_in_program184 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_program186 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _PROGRAM_in_program188 = new BitSet(new ulong[]{0x8000000000100UL});
		public static readonly BitSet _WS_in_program190 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_program193 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_program195 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_program197 = new BitSet(new ulong[]{0x8000020000000UL});
		public static readonly BitSet _WS_in_program199 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _LCURLY_in_program202 = new BitSet(new ulong[]{0x8000020000800UL});
		public static readonly BitSet _WS_in_program204 = new BitSet(new ulong[]{0x8000020000800UL});
		public static readonly BitSet _funcdecl_in_program207 = new BitSet(new ulong[]{0x8000020000800UL});
		public static readonly BitSet _WS_in_program210 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_program213 = new BitSet(new ulong[]{0x8010000000000UL});
		public static readonly BitSet _WS_in_program215 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _RCURLY_in_program218 = new BitSet(new ulong[]{0x8000000010000UL});
		public static readonly BitSet _WS_in_program220 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ENDP_in_program225 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOF_in_program231 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_blockstatement258 = new BitSet(new ulong[]{0x4030026000000UL});
		public static readonly BitSet _statement_in_blockstatement260 = new BitSet(new ulong[]{0x4030026000000UL});
		public static readonly BitSet _RCURLY_in_blockstatement263 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_assignment294 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_assignment296 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_assignment298 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_ifstatement332 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_ifstatement334 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_ifstatement337 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _RPAREN_in_ifstatement339 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _THEN_in_ifstatement342 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_ifstatement354 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _ELSE_in_ifstatement371 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_ifstatement383 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_whilestatement412 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_whilestatement414 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_whilestatement417 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _RPAREN_in_whilestatement419 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_whilestatement422 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_returnstatement439 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_returnstatement441 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignment_in_statement474 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _ifstatement_in_statement483 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _returnstatement_in_statement491 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _whilestatement_in_statement499 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _blockstatement_in_statement507 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _SEMI_in_statement527 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DECLARE_in_funcdecl546 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _FUNCTION_in_funcdecl548 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_funcdecl550 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl552 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_funcdecl554 = new BitSet(new ulong[]{0x40002000000UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl557 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _COMMA_in_funcdecl560 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl562 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _RPAREN_in_funcdecl568 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_funcdecl570 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CALL_in_funccall602 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_funccall604 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_funccall606 = new BitSet(new ulong[]{0x4084A080080UL});
		public static readonly BitSet _expression_in_funccall609 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _COMMA_in_funccall612 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_funccall614 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _RPAREN_in_funccall620 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_primary653 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_primary662 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_primary670 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funccall_in_primary686 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_primary694 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_primary697 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _RPAREN_in_primary699 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEGATE_in_unaryexpr718 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _primary_in_unaryexpr722 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryexpr_in_multexpr749 = new BitSet(new ulong[]{0x400002002UL});
		public static readonly BitSet _set_in_multexpr752 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _unaryexpr_in_multexpr759 = new BitSet(new ulong[]{0x400002002UL});
		public static readonly BitSet _multexpr_in_expression784 = new BitSet(new ulong[]{0x3381820012UL});
		public static readonly BitSet _set_in_expression787 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _multexpr_in_expression808 = new BitSet(new ulong[]{0x3381820012UL});
		public static readonly BitSet _WS_in_synpred6_MyLangParser204 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  PlayingWithDLR.MyScriptRuntime.Script 
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g 2012-01-06 22:53:24

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


  //using System.Collections.Generic;
  
  using System;
  using PlayingWithDLR.MyScriptRuntime;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  PlayingWithDLR.MyScriptRuntime.Script 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class MyLangTree : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ASSIGN", "BLOCKSTMT", "CALL", "COLON", "COMMA", "COMMENT", "DECLARE", "DIGIT", "DIVIDE", "DOT", "ELSE", "ENDP", "EQUALS", "EXPONENT", "FLOAT", "FUNCCALL", "FUNCDECL", "FUNCTION", "GT", "GTEQ", "IDENTIFIER", "IF", "INT", "LCLETTER", "LCURLY", "LPAREN", "LT", "LTEQ", "MINUS", "MULTIPLY", "NEGATE", "OR", "PLUS", "PROGDECL", "PROGRAM", "RCURLY", "RETURN", "RPAREN", "RUN", "RUNPROG", "SEMI", "THEN", "UCLETTER", "USCORE", "VAR", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int ASSIGN=5;
	public const int BLOCKSTMT=6;
	public const int CALL=7;
	public const int COLON=8;
	public const int COMMA=9;
	public const int COMMENT=10;
	public const int DECLARE=11;
	public const int DIGIT=12;
	public const int DIVIDE=13;
	public const int DOT=14;
	public const int ELSE=15;
	public const int ENDP=16;
	public const int EQUALS=17;
	public const int EXPONENT=18;
	public const int FLOAT=19;
	public const int FUNCCALL=20;
	public const int FUNCDECL=21;
	public const int FUNCTION=22;
	public const int GT=23;
	public const int GTEQ=24;
	public const int IDENTIFIER=25;
	public const int IF=26;
	public const int INT=27;
	public const int LCLETTER=28;
	public const int LCURLY=29;
	public const int LPAREN=30;
	public const int LT=31;
	public const int LTEQ=32;
	public const int MINUS=33;
	public const int MULTIPLY=34;
	public const int NEGATE=35;
	public const int OR=36;
	public const int PLUS=37;
	public const int PROGDECL=38;
	public const int PROGRAM=39;
	public const int RCURLY=40;
	public const int RETURN=41;
	public const int RPAREN=42;
	public const int RUN=43;
	public const int RUNPROG=44;
	public const int SEMI=45;
	public const int THEN=46;
	public const int UCLETTER=47;
	public const int USCORE=48;
	public const int VAR=49;
	public const int WHILE=50;
	public const int WS=51;

	public MyLangTree(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public MyLangTree(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return MyLangTree.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_runprogram();
	partial void LeaveRule_runprogram();

	// $ANTLR start "runprogram"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:21:1: runprogram returns [MyRunProgramNode result] : RUNPROG IDENTIFIER ;
	[GrammarRule("runprogram")]
	private MyRunProgramNode runprogram()
	{
		EnterRule_runprogram();
		EnterRule("runprogram", 1);
		TraceIn("runprogram", 1);
		MyRunProgramNode result = default(MyRunProgramNode);


		CommonTree IDENTIFIER1 = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "runprogram");
		DebugLocation(21, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:22:5: ( RUNPROG IDENTIFIER )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:23:5: RUNPROG IDENTIFIER
			{
			DebugLocation(23, 5);
			Match(input,RUNPROG,Follow._RUNPROG_in_runprogram81); if (state.failed) return result;
			DebugLocation(23, 13);
			IDENTIFIER1=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_runprogram83); if (state.failed) return result;
			DebugLocation(23, 24);
			if (state.backtracking == 0)
			{
				result = new MyRunProgramNode(IDENTIFIER1.Text);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("runprogram", 1);
			LeaveRule("runprogram", 1);
			LeaveRule_runprogram();
		}
		DebugLocation(24, 4);
		} finally { DebugExitRule(GrammarFileName, "runprogram"); }
		return result;

	}
	// $ANTLR end "runprogram"

	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:26:8: public program returns [MyProgramDeclNode result] : PROGDECL IDENTIFIER ( (f= funcdecl )* ) bs= blockstatement ;
	[GrammarRule("program")]
	public MyProgramDeclNode program()
	{
		EnterRule_program();
		EnterRule("program", 2);
		TraceIn("program", 2);
		MyProgramDeclNode result = default(MyProgramDeclNode);


		MyFunctionDecleration f = default(MyFunctionDecleration);
		MyStatementListNode bs = default(MyStatementListNode);

			    	
					List<MyFunctionDecleration> funcs = new List<MyFunctionDecleration>();
					string name = String.Empty;
					MyStatementListNode statementListNode = null;
				
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(26, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:37:5: ( PROGDECL IDENTIFIER ( (f= funcdecl )* ) bs= blockstatement )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:38:5: PROGDECL IDENTIFIER ( (f= funcdecl )* ) bs= blockstatement
			{
			DebugLocation(38, 5);
			Match(input,PROGDECL,Follow._PROGDECL_in_program139); if (state.failed) return result;
			DebugLocation(38, 14);
			Match(input,IDENTIFIER,Follow._IDENTIFIER_in_program141); if (state.failed) return result;
			DebugLocation(39, 7);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:39:7: ( (f= funcdecl )* )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:39:8: (f= funcdecl )*
			{
			DebugLocation(39, 8);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:39:8: (f= funcdecl )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==FUNCDECL))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:39:9: f= funcdecl
					{
					DebugLocation(39, 10);
					PushFollow(Follow._funcdecl_in_program154);
					f=funcdecl();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(39, 20);
					if (state.backtracking == 0)
					{
						funcs.Add(f);
					}

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			DebugLocation(39, 41);
			PushFollow(Follow._blockstatement_in_program163);
			bs=blockstatement();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(39, 57);
			if (state.backtracking == 0)
			{
				statementListNode=bs;
			}

			}

			if (state.backtracking == 0)
			{

				            result = new MyProgramDeclNode(name, funcs, statementListNode);
					    
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 2);
			LeaveRule("program", 2);
			LeaveRule_program();
		}
		DebugLocation(40, 4);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return result;

	}
	// $ANTLR end "program"

	partial void EnterRule_blockstatement();
	partial void LeaveRule_blockstatement();

	// $ANTLR start "blockstatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:42:1: blockstatement returns [MyStatementListNode result] : BLOCKSTMT (st= statement )* ;
	[GrammarRule("blockstatement")]
	private MyStatementListNode blockstatement()
	{
		EnterRule_blockstatement();
		EnterRule("blockstatement", 3);
		TraceIn("blockstatement", 3);
		MyStatementListNode result = default(MyStatementListNode);


		MyStatementNode st = default(MyStatementNode);

		try { DebugEnterRule(GrammarFileName, "blockstatement");
		DebugLocation(42, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:44:5: ( BLOCKSTMT (st= statement )* )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:44:7: BLOCKSTMT (st= statement )*
			{
			DebugLocation(44, 7);
			Match(input,BLOCKSTMT,Follow._BLOCKSTMT_in_blockstatement190); if (state.failed) return result;
			DebugLocation(45, 9);
			if (state.backtracking == 0)
			{

							result = new MyStatementListNode();
				        
			}
			DebugLocation(49, 5);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:49:5: (st= statement )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				switch (input.LA(1))
				{
				case BLOCKSTMT:
					{
					int LA2_2 = input.LA(2);

					if ((EvaluatePredicate(synpred2_MyLangTree_fragment)))
					{
						alt2 = 1;
					}


					}
					break;
				case ASSIGN:
					{
					int LA2_3 = input.LA(2);

					if ((EvaluatePredicate(synpred2_MyLangTree_fragment)))
					{
						alt2 = 1;
					}


					}
					break;
				case IF:
					{
					int LA2_4 = input.LA(2);

					if ((EvaluatePredicate(synpred2_MyLangTree_fragment)))
					{
						alt2 = 1;
					}


					}
					break;
				case RETURN:
					{
					int LA2_5 = input.LA(2);

					if ((EvaluatePredicate(synpred2_MyLangTree_fragment)))
					{
						alt2 = 1;
					}


					}
					break;
				case WHILE:
					{
					int LA2_6 = input.LA(2);

					if ((EvaluatePredicate(synpred2_MyLangTree_fragment)))
					{
						alt2 = 1;
					}


					}
					break;
				}

				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:49:6: st= statement
					{
					DebugLocation(49, 9);
					PushFollow(Follow._statement_in_blockstatement217);
					st=statement();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(49, 21);
					if (state.backtracking == 0)
					{
						 result.AddStatement(st); 
					}

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("blockstatement", 3);
			LeaveRule("blockstatement", 3);
			LeaveRule_blockstatement();
		}
		DebugLocation(50, 4);
		} finally { DebugExitRule(GrammarFileName, "blockstatement"); }
		return result;

	}
	// $ANTLR end "blockstatement"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();

	// $ANTLR start "assignment"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:52:1: assignment returns [MyAssignmentNode result] : ^( ASSIGN IDENTIFIER e= expression ) ;
	[GrammarRule("assignment")]
	private MyAssignmentNode assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 4);
		TraceIn("assignment", 4);
		MyAssignmentNode result = default(MyAssignmentNode);


		CommonTree IDENTIFIER2 = default(CommonTree);
		MyAbstractNode e = default(MyAbstractNode);

		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(52, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:53:5: ( ^( ASSIGN IDENTIFIER e= expression ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:53:7: ^( ASSIGN IDENTIFIER e= expression )
			{
			DebugLocation(53, 7);
			DebugLocation(53, 9);
			Match(input,ASSIGN,Follow._ASSIGN_in_assignment244); if (state.failed) return result;

			Match(input, TokenTypes.Down, null); if (state.failed) return result;
			DebugLocation(53, 16);
			IDENTIFIER2=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_assignment246); if (state.failed) return result;
			DebugLocation(53, 28);
			PushFollow(Follow._expression_in_assignment250);
			e=expression();
			PopFollow();
			if (state.failed) return result;

			Match(input, TokenTypes.Up, null); if (state.failed) return result;

			DebugLocation(54, 9);
			if (state.backtracking == 0)
			{

				            MyVariableNode v = new MyVariableNode(IDENTIFIER2.Text);
				            result = new MyAssignmentNode(v,e);
				        
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assignment", 4);
			LeaveRule("assignment", 4);
			LeaveRule_assignment();
		}
		DebugLocation(58, 4);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return result;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_ifstatement();
	partial void LeaveRule_ifstatement();

	// $ANTLR start "ifstatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:60:1: ifstatement returns [MyIfStatement result] : IF condition= expression thenpart= blockstatement ( (elsepart= blockstatement )? ) ;
	[GrammarRule("ifstatement")]
	private MyIfStatement ifstatement()
	{
		EnterRule_ifstatement();
		EnterRule("ifstatement", 5);
		TraceIn("ifstatement", 5);
		MyIfStatement result = default(MyIfStatement);


		MyAbstractNode condition = default(MyAbstractNode);
		MyStatementListNode thenpart = default(MyStatementListNode);
		MyStatementListNode elsepart = default(MyStatementListNode);

		try { DebugEnterRule(GrammarFileName, "ifstatement");
		DebugLocation(60, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:61:5: ( IF condition= expression thenpart= blockstatement ( (elsepart= blockstatement )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:62:5: IF condition= expression thenpart= blockstatement ( (elsepart= blockstatement )? )
			{
			DebugLocation(62, 5);
			Match(input,IF,Follow._IF_in_ifstatement288); if (state.failed) return result;
			DebugLocation(62, 17);
			PushFollow(Follow._expression_in_ifstatement292);
			condition=expression();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(62, 37);
			PushFollow(Follow._blockstatement_in_ifstatement296);
			thenpart=blockstatement();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(63, 6);
			if (state.backtracking == 0)
			{

				            result = new MyIfStatement(condition, thenpart);
				    	
			}
			DebugLocation(66, 6);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:66:6: ( (elsepart= blockstatement )? )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:66:7: (elsepart= blockstatement )?
			{
			DebugLocation(66, 16);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:66:16: (elsepart= blockstatement )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==BLOCKSTMT))
			{
				int LA3_1 = input.LA(2);

				if ((EvaluatePredicate(synpred3_MyLangTree_fragment)))
				{
					alt3 = 1;
				}
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:66:16: elsepart= blockstatement
				{
				DebugLocation(66, 16);
				PushFollow(Follow._blockstatement_in_ifstatement316);
				elsepart=blockstatement();
				PopFollow();
				if (state.failed) return result;

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(66, 34);
			if (state.backtracking == 0)
			{
				result.ElsePart = elsepart;
			}

			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ifstatement", 5);
			LeaveRule("ifstatement", 5);
			LeaveRule_ifstatement();
		}
		DebugLocation(67, 4);
		} finally { DebugExitRule(GrammarFileName, "ifstatement"); }
		return result;

	}
	// $ANTLR end "ifstatement"

	partial void EnterRule_whilestatement();
	partial void LeaveRule_whilestatement();

	// $ANTLR start "whilestatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:69:1: whilestatement returns [MyWhileStatement result] : WHILE e= expression bs= blockstatement ;
	[GrammarRule("whilestatement")]
	private MyWhileStatement whilestatement()
	{
		EnterRule_whilestatement();
		EnterRule("whilestatement", 6);
		TraceIn("whilestatement", 6);
		MyWhileStatement result = default(MyWhileStatement);


		MyAbstractNode e = default(MyAbstractNode);
		MyStatementListNode bs = default(MyStatementListNode);

		try { DebugEnterRule(GrammarFileName, "whilestatement");
		DebugLocation(69, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:70:5: ( WHILE e= expression bs= blockstatement )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:71:5: WHILE e= expression bs= blockstatement
			{
			DebugLocation(71, 5);
			Match(input,WHILE,Follow._WHILE_in_whilestatement346); if (state.failed) return result;
			DebugLocation(71, 12);
			PushFollow(Follow._expression_in_whilestatement350);
			e=expression();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(71, 26);
			PushFollow(Follow._blockstatement_in_whilestatement354);
			bs=blockstatement();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(71, 42);
			if (state.backtracking == 0)
			{
				result = new MyWhileStatement(e, bs); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("whilestatement", 6);
			LeaveRule("whilestatement", 6);
			LeaveRule_whilestatement();
		}
		DebugLocation(72, 4);
		} finally { DebugExitRule(GrammarFileName, "whilestatement"); }
		return result;

	}
	// $ANTLR end "whilestatement"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:75:1: statement returns [MyStatementNode result] : (a= assignment |i= ifstatement |r= returnstatement |w= whilestatement |bs= blockstatement ) ;
	[GrammarRule("statement")]
	private MyStatementNode statement()
	{
		EnterRule_statement();
		EnterRule("statement", 7);
		TraceIn("statement", 7);
		MyStatementNode result = default(MyStatementNode);


		MyAssignmentNode a = default(MyAssignmentNode);
		MyIfStatement i = default(MyIfStatement);
		MyReturnStatement r = default(MyReturnStatement);
		MyWhileStatement w = default(MyWhileStatement);
		MyStatementListNode bs = default(MyStatementListNode);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(75, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:76:5: ( (a= assignment |i= ifstatement |r= returnstatement |w= whilestatement |bs= blockstatement ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:77:5: (a= assignment |i= ifstatement |r= returnstatement |w= whilestatement |bs= blockstatement )
			{
			DebugLocation(77, 5);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:77:5: (a= assignment |i= ifstatement |r= returnstatement |w= whilestatement |bs= blockstatement )
			int alt4=5;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case ASSIGN:
				{
				alt4 = 1;
				}
				break;
			case IF:
				{
				alt4 = 2;
				}
				break;
			case RETURN:
				{
				alt4 = 3;
				}
				break;
			case WHILE:
				{
				alt4 = 4;
				}
				break;
			case BLOCKSTMT:
				{
				alt4 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:78:7: a= assignment
				{
				DebugLocation(78, 8);
				PushFollow(Follow._assignment_in_statement396);
				a=assignment();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(78, 22);
				if (state.backtracking == 0)
				{
					result = a;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:79:7: i= ifstatement
				{
				DebugLocation(79, 8);
				PushFollow(Follow._ifstatement_in_statement410);
				i=ifstatement();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(79, 22);
				if (state.backtracking == 0)
				{
					result = i;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:80:7: r= returnstatement
				{
				DebugLocation(80, 8);
				PushFollow(Follow._returnstatement_in_statement423);
				r=returnstatement();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(80, 25);
				if (state.backtracking == 0)
				{
					result = r;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:81:7: w= whilestatement
				{
				DebugLocation(81, 8);
				PushFollow(Follow._whilestatement_in_statement435);
				w=whilestatement();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(81, 24);
				if (state.backtracking == 0)
				{
					result = w;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:82:7: bs= blockstatement
				{
				DebugLocation(82, 9);
				PushFollow(Follow._blockstatement_in_statement447);
				bs=blockstatement();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(82, 25);
				if (state.backtracking == 0)
				{
					result = bs;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 7);
			LeaveRule("statement", 7);
			LeaveRule_statement();
		}
		DebugLocation(84, 4);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return result;

	}
	// $ANTLR end "statement"

	partial void EnterRule_returnstatement();
	partial void LeaveRule_returnstatement();

	// $ANTLR start "returnstatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:85:1: returnstatement returns [MyReturnStatement result] : RETURN e= expression ;
	[GrammarRule("returnstatement")]
	private MyReturnStatement returnstatement()
	{
		EnterRule_returnstatement();
		EnterRule("returnstatement", 8);
		TraceIn("returnstatement", 8);
		MyReturnStatement result = default(MyReturnStatement);


		MyAbstractNode e = default(MyAbstractNode);

		try { DebugEnterRule(GrammarFileName, "returnstatement");
		DebugLocation(85, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:86:5: ( RETURN e= expression )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:86:7: RETURN e= expression
			{
			DebugLocation(86, 7);
			Match(input,RETURN,Follow._RETURN_in_returnstatement475); if (state.failed) return result;
			DebugLocation(86, 15);
			PushFollow(Follow._expression_in_returnstatement479);
			e=expression();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(86, 27);
			if (state.backtracking == 0)
			{
				result = new MyReturnStatement(e);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("returnstatement", 8);
			LeaveRule("returnstatement", 8);
			LeaveRule_returnstatement();
		}
		DebugLocation(87, 4);
		} finally { DebugExitRule(GrammarFileName, "returnstatement"); }
		return result;

	}
	// $ANTLR end "returnstatement"

	partial void EnterRule_funcdecl();
	partial void LeaveRule_funcdecl();

	// $ANTLR start "funcdecl"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:90:1: funcdecl returns [MyFunctionDecleration result = new MyFunctionDecleration()] : FUNCDECL funcname= IDENTIFIER (p= IDENTIFIER )* bs= blockstatement ;
	[GrammarRule("funcdecl")]
	private MyFunctionDecleration funcdecl()
	{
		EnterRule_funcdecl();
		EnterRule("funcdecl", 9);
		TraceIn("funcdecl", 9);
		MyFunctionDecleration result =  new MyFunctionDecleration();


		CommonTree funcname = default(CommonTree);
		CommonTree p = default(CommonTree);
		MyStatementListNode bs = default(MyStatementListNode);

		try { DebugEnterRule(GrammarFileName, "funcdecl");
		DebugLocation(90, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:91:5: ( FUNCDECL funcname= IDENTIFIER (p= IDENTIFIER )* bs= blockstatement )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:92:5: FUNCDECL funcname= IDENTIFIER (p= IDENTIFIER )* bs= blockstatement
			{
			DebugLocation(92, 5);
			Match(input,FUNCDECL,Follow._FUNCDECL_in_funcdecl508); if (state.failed) return result;
			DebugLocation(93, 14);
			funcname=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl519); if (state.failed) return result;
			DebugLocation(94, 6);
			if (state.backtracking == 0)
			{

				    		result.Name = funcname.Text;
				    	
			}
			DebugLocation(97, 5);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:97:5: (p= IDENTIFIER )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==IDENTIFIER))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:97:7: p= IDENTIFIER
					{
					DebugLocation(97, 9);
					p=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl539); if (state.failed) return result;
					DebugLocation(97, 23);
					if (state.backtracking == 0)
					{
						result.Params.Add(p.Text);
					}

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(98, 7);
			PushFollow(Follow._blockstatement_in_funcdecl554);
			bs=blockstatement();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(99, 9);
			if (state.backtracking == 0)
			{

				            result.Statements = bs;
				        
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcdecl", 9);
			LeaveRule("funcdecl", 9);
			LeaveRule_funcdecl();
		}
		DebugLocation(102, 4);
		} finally { DebugExitRule(GrammarFileName, "funcdecl"); }
		return result;

	}
	// $ANTLR end "funcdecl"

	partial void EnterRule_funccall();
	partial void LeaveRule_funccall();

	// $ANTLR start "funccall"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:104:1: funccall returns [MyFunctionCallNode result] : FUNCCALL id= IDENTIFIER vpl= valueparamlist ;
	[GrammarRule("funccall")]
	private MyFunctionCallNode funccall()
	{
		EnterRule_funccall();
		EnterRule("funccall", 10);
		TraceIn("funccall", 10);
		MyFunctionCallNode result = default(MyFunctionCallNode);


		CommonTree id = default(CommonTree);
		List<MyAbstractNode> vpl = default(List<MyAbstractNode>);

		try { DebugEnterRule(GrammarFileName, "funccall");
		DebugLocation(104, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:105:5: ( FUNCCALL id= IDENTIFIER vpl= valueparamlist )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:105:8: FUNCCALL id= IDENTIFIER vpl= valueparamlist
			{
			DebugLocation(105, 8);
			Match(input,FUNCCALL,Follow._FUNCCALL_in_funccall586); if (state.failed) return result;
			DebugLocation(105, 20);
			id=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funccall592); if (state.failed) return result;
			DebugLocation(105, 37);
			PushFollow(Follow._valueparamlist_in_funccall598);
			vpl=valueparamlist();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(106, 13);
			if (state.backtracking == 0)
			{

				                result = new MyFunctionCallNode(id.Text, vpl);
				            
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funccall", 10);
			LeaveRule("funccall", 10);
			LeaveRule_funccall();
		}
		DebugLocation(109, 4);
		} finally { DebugExitRule(GrammarFileName, "funccall"); }
		return result;

	}
	// $ANTLR end "funccall"

	partial void EnterRule_valueparamlist();
	partial void LeaveRule_valueparamlist();

	// $ANTLR start "valueparamlist"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:112:1: valueparamlist returns [List<MyAbstractNode> result] : e= expression (e= expression )* ;
	[GrammarRule("valueparamlist")]
	private List<MyAbstractNode> valueparamlist()
	{
		EnterRule_valueparamlist();
		EnterRule("valueparamlist", 11);
		TraceIn("valueparamlist", 11);
		List<MyAbstractNode> result = default(List<MyAbstractNode>);


		MyAbstractNode e = default(MyAbstractNode);

		try { DebugEnterRule(GrammarFileName, "valueparamlist");
		DebugLocation(112, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:113:5: (e= expression (e= expression )* )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:113:7: e= expression (e= expression )*
			{
			DebugLocation(113, 9);
			PushFollow(Follow._expression_in_valueparamlist643);
			e=expression();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(113, 22);
			if (state.backtracking == 0)
			{
				 
				                        result = new List<MyAbstractNode>();
				                        result.Add(e);
				                     
			}
			DebugLocation(117, 7);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:117:7: (e= expression )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==AND||LA6_0==DIVIDE||LA6_0==EQUALS||(LA6_0>=GT && LA6_0<=GTEQ)||(LA6_0>=LT && LA6_0<=PLUS)))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:117:8: e= expression
					{
					DebugLocation(117, 10);
					PushFollow(Follow._expression_in_valueparamlist658);
					e=expression();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(117, 23);
					if (state.backtracking == 0)
					{
						result.Add(e);
					}

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("valueparamlist", 11);
			LeaveRule("valueparamlist", 11);
			LeaveRule_valueparamlist();
		}
		DebugLocation(118, 4);
		} finally { DebugExitRule(GrammarFileName, "valueparamlist"); }
		return result;

	}
	// $ANTLR end "valueparamlist"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:125:1: expression returns [MyAbstractNode result] : ( PLUS left= expression right= expression | MINUS left= expression right= expression | MULTIPLY left= expression right= expression | DIVIDE left= expression right= expression | AND left= expression right= expression | OR left= expression right= expression | EQUALS left= expression right= expression | GT left= expression right= expression | GTEQ left= expression right= expression | LT left= expression right= expression | LTEQ left= expression right= expression | NEGATE op= expression );
	[GrammarRule("expression")]
	private MyAbstractNode expression()
	{
		EnterRule_expression();
		EnterRule("expression", 12);
		TraceIn("expression", 12);
		MyAbstractNode result = default(MyAbstractNode);


		MyAbstractNode left = default(MyAbstractNode);
		MyAbstractNode right = default(MyAbstractNode);
		MyAbstractNode op = default(MyAbstractNode);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(125, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:126:5: ( PLUS left= expression right= expression | MINUS left= expression right= expression | MULTIPLY left= expression right= expression | DIVIDE left= expression right= expression | AND left= expression right= expression | OR left= expression right= expression | EQUALS left= expression right= expression | GT left= expression right= expression | GTEQ left= expression right= expression | LT left= expression right= expression | LTEQ left= expression right= expression | NEGATE op= expression )
			int alt7=12;
			try { DebugEnterDecision(7, false);
			switch (input.LA(1))
			{
			case PLUS:
				{
				alt7 = 1;
				}
				break;
			case MINUS:
				{
				alt7 = 2;
				}
				break;
			case MULTIPLY:
				{
				alt7 = 3;
				}
				break;
			case DIVIDE:
				{
				alt7 = 4;
				}
				break;
			case AND:
				{
				alt7 = 5;
				}
				break;
			case OR:
				{
				alt7 = 6;
				}
				break;
			case EQUALS:
				{
				alt7 = 7;
				}
				break;
			case GT:
				{
				alt7 = 8;
				}
				break;
			case GTEQ:
				{
				alt7 = 9;
				}
				break;
			case LT:
				{
				alt7 = 10;
				}
				break;
			case LTEQ:
				{
				alt7 = 11;
				}
				break;
			case NEGATE:
				{
				alt7 = 12;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:126:7: PLUS left= expression right= expression
				{
				DebugLocation(126, 7);
				Match(input,PLUS,Follow._PLUS_in_expression706); if (state.failed) return result;
				DebugLocation(126, 16);
				PushFollow(Follow._expression_in_expression710);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(126, 33);
				PushFollow(Follow._expression_in_expression714);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(126, 46);
				if (state.backtracking == 0)
				{
					 result = new MyAddNode(left, right);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:127:7: MINUS left= expression right= expression
				{
				DebugLocation(127, 7);
				Match(input,MINUS,Follow._MINUS_in_expression725); if (state.failed) return result;
				DebugLocation(127, 18);
				PushFollow(Follow._expression_in_expression730);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(127, 35);
				PushFollow(Follow._expression_in_expression734);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(127, 47);
				if (state.backtracking == 0)
				{
					 result = new MyMinusNode(left, right);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:128:7: MULTIPLY left= expression right= expression
				{
				DebugLocation(128, 7);
				Match(input,MULTIPLY,Follow._MULTIPLY_in_expression744); if (state.failed) return result;
				DebugLocation(128, 21);
				PushFollow(Follow._expression_in_expression749);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(128, 38);
				PushFollow(Follow._expression_in_expression753);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(128, 49);
				if (state.backtracking == 0)
				{
					 result = new MyMultiplyNode(left, right);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:129:7: DIVIDE left= expression right= expression
				{
				DebugLocation(129, 7);
				Match(input,DIVIDE,Follow._DIVIDE_in_expression762); if (state.failed) return result;
				DebugLocation(129, 19);
				PushFollow(Follow._expression_in_expression767);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(129, 36);
				PushFollow(Follow._expression_in_expression771);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(129, 48);
				if (state.backtracking == 0)
				{
					 result = new MyDivideNode(left, right);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:130:7: AND left= expression right= expression
				{
				DebugLocation(130, 7);
				Match(input,AND,Follow._AND_in_expression781); if (state.failed) return result;
				DebugLocation(130, 15);
				PushFollow(Follow._expression_in_expression785);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(130, 32);
				PushFollow(Follow._expression_in_expression789);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(130, 45);
				if (state.backtracking == 0)
				{
					 result = new MyLogicalAndNode(left, right);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:131:7: OR left= expression right= expression
				{
				DebugLocation(131, 7);
				Match(input,OR,Follow._OR_in_expression800); if (state.failed) return result;
				DebugLocation(131, 14);
				PushFollow(Follow._expression_in_expression804);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(131, 31);
				PushFollow(Follow._expression_in_expression808);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(131, 44);
				if (state.backtracking == 0)
				{
					 result = new MyLogicalOrNode(left, right);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:132:7: EQUALS left= expression right= expression
				{
				DebugLocation(132, 7);
				Match(input,EQUALS,Follow._EQUALS_in_expression819); if (state.failed) return result;
				DebugLocation(132, 18);
				PushFollow(Follow._expression_in_expression823);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(132, 35);
				PushFollow(Follow._expression_in_expression827);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(132, 47);
				if (state.backtracking == 0)
				{
					 result = new MyIsEqualsNode(left, right);
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:133:7: GT left= expression right= expression
				{
				DebugLocation(133, 7);
				Match(input,GT,Follow._GT_in_expression837); if (state.failed) return result;
				DebugLocation(133, 14);
				PushFollow(Follow._expression_in_expression841);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(133, 31);
				PushFollow(Follow._expression_in_expression845);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(133, 44);
				if (state.backtracking == 0)
				{
					 result = new MyIsGreaterThanNode(left, right);
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:134:7: GTEQ left= expression right= expression
				{
				DebugLocation(134, 7);
				Match(input,GTEQ,Follow._GTEQ_in_expression856); if (state.failed) return result;
				DebugLocation(134, 16);
				PushFollow(Follow._expression_in_expression860);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(134, 33);
				PushFollow(Follow._expression_in_expression864);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(134, 46);
				if (state.backtracking == 0)
				{
					 result = new MyIsGreaterThanOrEqualNode(left, right);
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:135:7: LT left= expression right= expression
				{
				DebugLocation(135, 7);
				Match(input,LT,Follow._LT_in_expression875); if (state.failed) return result;
				DebugLocation(135, 14);
				PushFollow(Follow._expression_in_expression879);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(135, 31);
				PushFollow(Follow._expression_in_expression883);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(135, 44);
				if (state.backtracking == 0)
				{
					 result = new MyIsLessThanNode(left, right);
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:136:7: LTEQ left= expression right= expression
				{
				DebugLocation(136, 7);
				Match(input,LTEQ,Follow._LTEQ_in_expression894); if (state.failed) return result;
				DebugLocation(136, 16);
				PushFollow(Follow._expression_in_expression898);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(136, 33);
				PushFollow(Follow._expression_in_expression902);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(136, 46);
				if (state.backtracking == 0)
				{
					 result = new MyIsLessThanOrEqualNode(left, right);
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:137:7: NEGATE op= expression
				{
				DebugLocation(137, 7);
				Match(input,NEGATE,Follow._NEGATE_in_expression913); if (state.failed) return result;
				DebugLocation(137, 16);
				PushFollow(Follow._expression_in_expression917);
				op=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(137, 33);
				if (state.backtracking == 0)
				{
					 result = new MyMinusNode( new MyValueNode(0), op);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 12);
			LeaveRule("expression", 12);
			LeaveRule_expression();
		}
		DebugLocation(138, 4);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return result;

	}
	// $ANTLR end "expression"

	partial void EnterRule_primary();
	partial void LeaveRule_primary();

	// $ANTLR start "primary"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:139:1: primary returns [MyAbstractNode result] : ( INT | FLOAT |id= IDENTIFIER |fc= funccall |e= expression );
	[GrammarRule("primary")]
	private MyAbstractNode primary()
	{
		EnterRule_primary();
		EnterRule("primary", 13);
		TraceIn("primary", 13);
		MyAbstractNode result = default(MyAbstractNode);


		CommonTree id = default(CommonTree);
		CommonTree INT3 = default(CommonTree);
		CommonTree FLOAT4 = default(CommonTree);
		MyFunctionCallNode fc = default(MyFunctionCallNode);
		MyAbstractNode e = default(MyAbstractNode);

		try { DebugEnterRule(GrammarFileName, "primary");
		DebugLocation(139, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:140:5: ( INT | FLOAT |id= IDENTIFIER |fc= funccall |e= expression )
			int alt8=5;
			try { DebugEnterDecision(8, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt8 = 1;
				}
				break;
			case FLOAT:
				{
				alt8 = 2;
				}
				break;
			case IDENTIFIER:
				{
				alt8 = 3;
				}
				break;
			case FUNCCALL:
				{
				alt8 = 4;
				}
				break;
			case AND:
			case DIVIDE:
			case EQUALS:
			case GT:
			case GTEQ:
			case LT:
			case LTEQ:
			case MINUS:
			case MULTIPLY:
			case NEGATE:
			case OR:
			case PLUS:
				{
				alt8 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:140:7: INT
				{
				DebugLocation(140, 7);
				INT3=(CommonTree)Match(input,INT,Follow._INT_in_primary944); if (state.failed) return result;
				DebugLocation(140, 13);
				if (state.backtracking == 0)
				{
					result = new MyValueNode(Int32.Parse(INT3.Text));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:141:7: FLOAT
				{
				DebugLocation(141, 7);
				FLOAT4=(CommonTree)Match(input,FLOAT,Follow._FLOAT_in_primary956); if (state.failed) return result;
				DebugLocation(141, 13);
				if (state.backtracking == 0)
				{
					result = new MyValueNode(Double.Parse(FLOAT4.Text));
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:142:7: id= IDENTIFIER
				{
				DebugLocation(142, 9);
				id=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_primary968); if (state.failed) return result;
				DebugLocation(142, 21);
				if (state.backtracking == 0)
				{
					result = new MyVariableNode(id.Text);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:143:7: fc= funccall
				{
				DebugLocation(143, 9);
				PushFollow(Follow._funccall_in_primary980);
				fc=funccall();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(143, 19);
				if (state.backtracking == 0)
				{
					result = fc;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:144:7: e= expression
				{
				DebugLocation(144, 8);
				PushFollow(Follow._expression_in_primary992);
				e=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(144, 20);
				if (state.backtracking == 0)
				{
					result = e;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("primary", 13);
			LeaveRule("primary", 13);
			LeaveRule_primary();
		}
		DebugLocation(145, 4);
		} finally { DebugExitRule(GrammarFileName, "primary"); }
		return result;

	}
	// $ANTLR end "primary"

	partial void EnterRule_synpred2_MyLangTree_fragment();
	partial void LeaveRule_synpred2_MyLangTree_fragment();

	// $ANTLR start synpred2_MyLangTree
	public void synpred2_MyLangTree_fragment()
	{
		MyStatementNode st = default(MyStatementNode);

		EnterRule_synpred2_MyLangTree_fragment();
		EnterRule("synpred2_MyLangTree_fragment", 15);
		TraceIn("synpred2_MyLangTree_fragment", 15);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:49:6: (st= statement )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:49:6: st= statement
			{
			DebugLocation(49, 9);
			PushFollow(Follow._statement_in_synpred2_MyLangTree217);
			st=statement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_MyLangTree_fragment", 15);
			LeaveRule("synpred2_MyLangTree_fragment", 15);
			LeaveRule_synpred2_MyLangTree_fragment();
		}
	}
	// $ANTLR end synpred2_MyLangTree

	partial void EnterRule_synpred3_MyLangTree_fragment();
	partial void LeaveRule_synpred3_MyLangTree_fragment();

	// $ANTLR start synpred3_MyLangTree
	public void synpred3_MyLangTree_fragment()
	{
		MyStatementListNode elsepart = default(MyStatementListNode);

		EnterRule_synpred3_MyLangTree_fragment();
		EnterRule("synpred3_MyLangTree_fragment", 16);
		TraceIn("synpred3_MyLangTree_fragment", 16);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:66:16: (elsepart= blockstatement )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangTree.g:66:16: elsepart= blockstatement
			{
			DebugLocation(66, 16);
			PushFollow(Follow._blockstatement_in_synpred3_MyLangTree316);
			elsepart=blockstatement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_MyLangTree_fragment", 16);
			LeaveRule("synpred3_MyLangTree_fragment", 16);
			LeaveRule_synpred3_MyLangTree_fragment();
		}
	}
	// $ANTLR end synpred3_MyLangTree
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _RUNPROG_in_runprogram81 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_runprogram83 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PROGDECL_in_program139 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_program141 = new BitSet(new ulong[]{0x200040UL});
		public static readonly BitSet _funcdecl_in_program154 = new BitSet(new ulong[]{0x200040UL});
		public static readonly BitSet _blockstatement_in_program163 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BLOCKSTMT_in_blockstatement190 = new BitSet(new ulong[]{0x4020004000062UL});
		public static readonly BitSet _statement_in_blockstatement217 = new BitSet(new ulong[]{0x4020004000062UL});
		public static readonly BitSet _ASSIGN_in_assignment244 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENTIFIER_in_assignment246 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_assignment250 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IF_in_ifstatement288 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_ifstatement292 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _blockstatement_in_ifstatement296 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _blockstatement_in_ifstatement316 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_whilestatement346 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_whilestatement350 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _blockstatement_in_whilestatement354 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignment_in_statement396 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifstatement_in_statement410 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnstatement_in_statement423 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whilestatement_in_statement435 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _blockstatement_in_statement447 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_returnstatement475 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_returnstatement479 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCDECL_in_funcdecl508 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl519 = new BitSet(new ulong[]{0x2000040UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl539 = new BitSet(new ulong[]{0x2000040UL});
		public static readonly BitSet _blockstatement_in_funcdecl554 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCCALL_in_funccall586 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_funccall592 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _valueparamlist_in_funccall598 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_valueparamlist643 = new BitSet(new ulong[]{0x3F81822012UL});
		public static readonly BitSet _expression_in_valueparamlist658 = new BitSet(new ulong[]{0x3F81822012UL});
		public static readonly BitSet _PLUS_in_expression706 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression710 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression714 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_expression725 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression730 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression734 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MULTIPLY_in_expression744 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression749 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression753 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DIVIDE_in_expression762 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression767 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression771 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AND_in_expression781 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression785 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression789 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OR_in_expression800 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression804 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression808 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQUALS_in_expression819 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression823 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression827 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GT_in_expression837 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression841 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression845 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GTEQ_in_expression856 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression860 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression864 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_expression875 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression879 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression883 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LTEQ_in_expression894 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression898 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression902 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEGATE_in_expression913 = new BitSet(new ulong[]{0x3F81822010UL});
		public static readonly BitSet _expression_in_expression917 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_primary944 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_primary956 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_primary968 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funccall_in_primary980 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_primary992 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_synpred2_MyLangTree217 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _blockstatement_in_synpred3_MyLangTree316 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  PlayingWithDLR.MyScriptRuntime.Script 
