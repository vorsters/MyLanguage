//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g 2012-01-06 21:54:55

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class MyLang3Parser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "IDENT", "INT", "WS", "':='", "';'"
	};
	public const int EOF=-1;
	public const int T__7=7;
	public const int T__8=8;
	public const int IDENT=4;
	public const int INT=5;
	public const int WS=6;

	public MyLang3Parser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public MyLang3Parser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return MyLang3Parser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_evaluator();
	partial void LeaveRule_evaluator();

	// $ANTLR start "evaluator"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:10:1: evaluator : ( assignment )* INT EOF !;
	[GrammarRule("evaluator")]
	private AstParserRuleReturnScope<CommonTree, IToken> evaluator()
	{
		EnterRule_evaluator();
		EnterRule("evaluator", 1);
		TraceIn("evaluator", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INT2 = default(IToken);
		IToken EOF3 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignment1 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INT2_tree = default(CommonTree);
		CommonTree EOF3_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "evaluator");
		DebugLocation(10, 1);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:11:2: ( ( assignment )* INT EOF !)
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:11:4: ( assignment )* INT EOF !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(11, 4);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:11:4: ( assignment )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==IDENT))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:11:4: assignment
					{
					DebugLocation(11, 4);
					PushFollow(Follow._assignment_in_evaluator40);
					assignment1=assignment();
					PopFollow();

					adaptor.AddChild(root_0, assignment1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(11, 16);
			INT2=(IToken)Match(input,INT,Follow._INT_in_evaluator43); 
			INT2_tree = (CommonTree)adaptor.Create(INT2);
			adaptor.AddChild(root_0, INT2_tree);
			DebugLocation(11, 23);
			EOF3=(IToken)Match(input,EOF,Follow._EOF_in_evaluator45); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("evaluator", 1);
			LeaveRule("evaluator", 1);
			LeaveRule_evaluator();
		}
		DebugLocation(12, 1);
		} finally { DebugExitRule(GrammarFileName, "evaluator"); }
		return retval;

	}
	// $ANTLR end "evaluator"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();

	// $ANTLR start "assignment"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:14:1: assignment : IDENT ':=' ^ INT ';' !;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 2);
		TraceIn("assignment", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT4 = default(IToken);
		IToken string_literal5 = default(IToken);
		IToken INT6 = default(IToken);
		IToken char_literal7 = default(IToken);

		CommonTree IDENT4_tree = default(CommonTree);
		CommonTree string_literal5_tree = default(CommonTree);
		CommonTree INT6_tree = default(CommonTree);
		CommonTree char_literal7_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(14, 1);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:15:2: ( IDENT ':=' ^ INT ';' !)
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLang3.g:15:4: IDENT ':=' ^ INT ';' !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(15, 4);
			IDENT4=(IToken)Match(input,IDENT,Follow._IDENT_in_assignment58); 
			IDENT4_tree = (CommonTree)adaptor.Create(IDENT4);
			adaptor.AddChild(root_0, IDENT4_tree);
			DebugLocation(15, 14);
			string_literal5=(IToken)Match(input,7,Follow._7_in_assignment60); 
			string_literal5_tree = (CommonTree)adaptor.Create(string_literal5);
			root_0 = (CommonTree)adaptor.BecomeRoot(string_literal5_tree, root_0);
			DebugLocation(15, 16);
			INT6=(IToken)Match(input,INT,Follow._INT_in_assignment63); 
			INT6_tree = (CommonTree)adaptor.Create(INT6);
			adaptor.AddChild(root_0, INT6_tree);
			DebugLocation(15, 23);
			char_literal7=(IToken)Match(input,8,Follow._8_in_assignment65); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 2);
			LeaveRule("assignment", 2);
			LeaveRule_assignment();
		}
		DebugLocation(16, 1);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _assignment_in_evaluator40 = new BitSet(new ulong[]{0x30UL});
		public static readonly BitSet _INT_in_evaluator43 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_evaluator45 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_assignment58 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _7_in_assignment60 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _INT_in_assignment63 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _8_in_assignment65 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
