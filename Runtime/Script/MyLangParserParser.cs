//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g 2012-01-06 18:12:16

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  PlayingWithDLR.MyScriptRuntime.Script 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class MyLangParserParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ASSIGN", "BLOCKSTMT", "CALL", "COLON", "COMMA", "COMMENT", "DECLARE", "DIGIT", "DIVIDE", "DOT", "ELSE", "ENDP", "EQUALS", "EXPONENT", "FLOAT", "FUNCCALL", "FUNCDECL", "FUNCTION", "GT", "GTEQ", "IDENTIFIER", "IF", "INT", "LCLETTER", "LCURLY", "LPAREN", "LT", "LTEQ", "MINUS", "MULTIPLY", "NEGATE", "OR", "PLUS", "PROGDECL", "PROGRAM", "RCURLY", "RETURN", "RPAREN", "RUN", "RUNPROG", "SEMI", "THEN", "UCLETTER", "USCORE", "VAR", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int ASSIGN=5;
	public const int BLOCKSTMT=6;
	public const int CALL=7;
	public const int COLON=8;
	public const int COMMA=9;
	public const int COMMENT=10;
	public const int DECLARE=11;
	public const int DIGIT=12;
	public const int DIVIDE=13;
	public const int DOT=14;
	public const int ELSE=15;
	public const int ENDP=16;
	public const int EQUALS=17;
	public const int EXPONENT=18;
	public const int FLOAT=19;
	public const int FUNCCALL=20;
	public const int FUNCDECL=21;
	public const int FUNCTION=22;
	public const int GT=23;
	public const int GTEQ=24;
	public const int IDENTIFIER=25;
	public const int IF=26;
	public const int INT=27;
	public const int LCLETTER=28;
	public const int LCURLY=29;
	public const int LPAREN=30;
	public const int LT=31;
	public const int LTEQ=32;
	public const int MINUS=33;
	public const int MULTIPLY=34;
	public const int NEGATE=35;
	public const int OR=36;
	public const int PLUS=37;
	public const int PROGDECL=38;
	public const int PROGRAM=39;
	public const int RCURLY=40;
	public const int RETURN=41;
	public const int RPAREN=42;
	public const int RUN=43;
	public const int RUNPROG=44;
	public const int SEMI=45;
	public const int THEN=46;
	public const int UCLETTER=47;
	public const int USCORE=48;
	public const int VAR=49;
	public const int WHILE=50;
	public const int WS=51;

	public MyLangParserParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public MyLangParserParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return MyLangParserParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_runprogram();
	partial void LeaveRule_runprogram();

	// $ANTLR start "runprogram"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:37:8: public runprogram : RUN PROGRAM IDENTIFIER EOF -> ^( RUNPROG IDENTIFIER ) ;
	[GrammarRule("runprogram")]
	public AstParserRuleReturnScope<CommonTree, IToken> runprogram()
	{
		EnterRule_runprogram();
		EnterRule("runprogram", 1);
		TraceIn("runprogram", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken RUN1 = default(IToken);
		IToken PROGRAM2 = default(IToken);
		IToken IDENTIFIER3 = default(IToken);
		IToken EOF4 = default(IToken);

		CommonTree RUN1_tree = default(CommonTree);
		CommonTree PROGRAM2_tree = default(CommonTree);
		CommonTree IDENTIFIER3_tree = default(CommonTree);
		CommonTree EOF4_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RUN=new RewriteRuleITokenStream(adaptor,"token RUN");
		RewriteRuleITokenStream stream_PROGRAM=new RewriteRuleITokenStream(adaptor,"token PROGRAM");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		try { DebugEnterRule(GrammarFileName, "runprogram");
		DebugLocation(37, 57);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:39:5: ( RUN PROGRAM IDENTIFIER EOF -> ^( RUNPROG IDENTIFIER ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:39:7: RUN PROGRAM IDENTIFIER EOF
			{
			DebugLocation(39, 7);
			RUN1=(IToken)Match(input,RUN,Follow._RUN_in_runprogram141); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RUN.Add(RUN1);

			DebugLocation(39, 11);
			PROGRAM2=(IToken)Match(input,PROGRAM,Follow._PROGRAM_in_runprogram143); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PROGRAM.Add(PROGRAM2);

			DebugLocation(39, 19);
			IDENTIFIER3=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_runprogram145); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER3);

			DebugLocation(39, 30);
			EOF4=(IToken)Match(input,EOF,Follow._EOF_in_runprogram147); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF4);



			{
			// AST REWRITE
			// elements: IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 39:34: -> ^( RUNPROG IDENTIFIER )
			{
				DebugLocation(39, 37);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:39:37: ^( RUNPROG IDENTIFIER )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(39, 39);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(RUNPROG, "RUNPROG"), root_1);

				DebugLocation(39, 47);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("runprogram", 1);
			LeaveRule("runprogram", 1);
			LeaveRule_runprogram();
		}
		DebugLocation(39, 57);
		} finally { DebugExitRule(GrammarFileName, "runprogram"); }
		return retval;

	}
	// $ANTLR end "runprogram"

	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:41:8: public program : DECLARE PROGRAM COLON IDENTIFIER LCURLY ( funcdecl )* blockstatement RCURLY ( ( ENDP ) | EOF ) -> ^( PROGDECL IDENTIFIER ( funcdecl )* blockstatement ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 2);
		TraceIn("program", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DECLARE5 = default(IToken);
		IToken PROGRAM6 = default(IToken);
		IToken COLON7 = default(IToken);
		IToken IDENTIFIER8 = default(IToken);
		IToken LCURLY9 = default(IToken);
		IToken RCURLY12 = default(IToken);
		IToken ENDP13 = default(IToken);
		IToken EOF14 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> funcdecl10 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement11 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DECLARE5_tree = default(CommonTree);
		CommonTree PROGRAM6_tree = default(CommonTree);
		CommonTree COLON7_tree = default(CommonTree);
		CommonTree IDENTIFIER8_tree = default(CommonTree);
		CommonTree LCURLY9_tree = default(CommonTree);
		CommonTree RCURLY12_tree = default(CommonTree);
		CommonTree ENDP13_tree = default(CommonTree);
		CommonTree EOF14_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ENDP=new RewriteRuleITokenStream(adaptor,"token ENDP");
		RewriteRuleITokenStream stream_DECLARE=new RewriteRuleITokenStream(adaptor,"token DECLARE");
		RewriteRuleITokenStream stream_PROGRAM=new RewriteRuleITokenStream(adaptor,"token PROGRAM");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_blockstatement=new RewriteRuleSubtreeStream(adaptor,"rule blockstatement");
		RewriteRuleSubtreeStream stream_funcdecl=new RewriteRuleSubtreeStream(adaptor,"rule funcdecl");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(41, 144);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:42:5: ( DECLARE PROGRAM COLON IDENTIFIER LCURLY ( funcdecl )* blockstatement RCURLY ( ( ENDP ) | EOF ) -> ^( PROGDECL IDENTIFIER ( funcdecl )* blockstatement ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:43:7: DECLARE PROGRAM COLON IDENTIFIER LCURLY ( funcdecl )* blockstatement RCURLY ( ( ENDP ) | EOF )
			{
			DebugLocation(43, 7);
			DECLARE5=(IToken)Match(input,DECLARE,Follow._DECLARE_in_program176); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DECLARE.Add(DECLARE5);

			DebugLocation(43, 15);
			PROGRAM6=(IToken)Match(input,PROGRAM,Follow._PROGRAM_in_program178); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PROGRAM.Add(PROGRAM6);

			DebugLocation(43, 23);
			COLON7=(IToken)Match(input,COLON,Follow._COLON_in_program180); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON7);

			DebugLocation(43, 29);
			IDENTIFIER8=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_program182); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER8);

			DebugLocation(43, 40);
			LCURLY9=(IToken)Match(input,LCURLY,Follow._LCURLY_in_program184); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY9);

			DebugLocation(43, 47);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:43:47: ( funcdecl )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==DECLARE))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:43:47: funcdecl
					{
					DebugLocation(43, 47);
					PushFollow(Follow._funcdecl_in_program186);
					funcdecl10=funcdecl();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_funcdecl.Add(funcdecl10.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(43, 57);
			PushFollow(Follow._blockstatement_in_program189);
			blockstatement11=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_blockstatement.Add(blockstatement11.Tree);
			DebugLocation(43, 72);
			RCURLY12=(IToken)Match(input,RCURLY,Follow._RCURLY_in_program191); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY12);

			DebugLocation(43, 79);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:43:79: ( ( ENDP ) | EOF )
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==ENDP))
			{
				alt2 = 1;
			}
			else if ((LA2_0==EOF))
			{
				alt2 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:43:80: ( ENDP )
				{
				DebugLocation(43, 80);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:43:80: ( ENDP )
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:43:81: ENDP
				{
				DebugLocation(43, 81);
				ENDP13=(IToken)Match(input,ENDP,Follow._ENDP_in_program195); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ENDP.Add(ENDP13);


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:43:90: EOF
				{
				DebugLocation(43, 90);
				EOF14=(IToken)Match(input,EOF,Follow._EOF_in_program201); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_EOF.Add(EOF14);


				}
				break;

			}
			} finally { DebugExitSubRule(2); }



			{
			// AST REWRITE
			// elements: blockstatement, IDENTIFIER, funcdecl
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 43:95: -> ^( PROGDECL IDENTIFIER ( funcdecl )* blockstatement )
			{
				DebugLocation(43, 98);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:43:98: ^( PROGDECL IDENTIFIER ( funcdecl )* blockstatement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(43, 100);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROGDECL, "PROGDECL"), root_1);

				DebugLocation(43, 109);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(43, 120);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:43:120: ( funcdecl )*
				while ( stream_funcdecl.HasNext )
				{
					DebugLocation(43, 120);
					adaptor.AddChild(root_1, stream_funcdecl.NextTree());

				}
				stream_funcdecl.Reset();
				DebugLocation(43, 130);
				adaptor.AddChild(root_1, stream_blockstatement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 2);
			LeaveRule("program", 2);
			LeaveRule_program();
		}
		DebugLocation(43, 144);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_blockstatement();
	partial void LeaveRule_blockstatement();

	// $ANTLR start "blockstatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:46:1: blockstatement : LCURLY ( statement )* RCURLY -> ^( BLOCKSTMT ( statement )* ) ;
	[GrammarRule("blockstatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> blockstatement()
	{
		EnterRule_blockstatement();
		EnterRule("blockstatement", 3);
		TraceIn("blockstatement", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LCURLY15 = default(IToken);
		IToken RCURLY17 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement16 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LCURLY15_tree = default(CommonTree);
		CommonTree RCURLY17_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "blockstatement");
		DebugLocation(46, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:47:5: ( LCURLY ( statement )* RCURLY -> ^( BLOCKSTMT ( statement )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:47:7: LCURLY ( statement )* RCURLY
			{
			DebugLocation(47, 7);
			LCURLY15=(IToken)Match(input,LCURLY,Follow._LCURLY_in_blockstatement229); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY15);

			DebugLocation(47, 14);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:47:14: ( statement )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if (((LA3_0>=IDENTIFIER && LA3_0<=IF)||LA3_0==LCURLY||LA3_0==RETURN||LA3_0==WHILE))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:47:14: statement
					{
					DebugLocation(47, 14);
					PushFollow(Follow._statement_in_blockstatement231);
					statement16=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement16.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(47, 25);
			RCURLY17=(IToken)Match(input,RCURLY,Follow._RCURLY_in_blockstatement234); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY17);



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 47:32: -> ^( BLOCKSTMT ( statement )* )
			{
				DebugLocation(47, 35);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:47:35: ^( BLOCKSTMT ( statement )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(47, 37);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BLOCKSTMT, "BLOCKSTMT"), root_1);

				DebugLocation(47, 47);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:47:47: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(47, 47);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("blockstatement", 3);
			LeaveRule("blockstatement", 3);
			LeaveRule_blockstatement();
		}
		DebugLocation(48, 4);
		} finally { DebugExitRule(GrammarFileName, "blockstatement"); }
		return retval;

	}
	// $ANTLR end "blockstatement"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();

	// $ANTLR start "assignment"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:50:1: assignment : IDENTIFIER ASSIGN expression -> ^( ASSIGN IDENTIFIER expression ) ;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 4);
		TraceIn("assignment", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENTIFIER18 = default(IToken);
		IToken ASSIGN19 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression20 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENTIFIER18_tree = default(CommonTree);
		CommonTree ASSIGN19_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(50, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:51:5: ( IDENTIFIER ASSIGN expression -> ^( ASSIGN IDENTIFIER expression ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:52:5: IDENTIFIER ASSIGN expression
			{
			DebugLocation(52, 5);
			IDENTIFIER18=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_assignment265); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER18);

			DebugLocation(52, 16);
			ASSIGN19=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_assignment267); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN19);

			DebugLocation(52, 23);
			PushFollow(Follow._expression_in_assignment269);
			expression20=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression20.Tree);


			{
			// AST REWRITE
			// elements: expression, ASSIGN, IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 52:34: -> ^( ASSIGN IDENTIFIER expression )
			{
				DebugLocation(52, 37);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:52:37: ^( ASSIGN IDENTIFIER expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(52, 39);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

				DebugLocation(52, 46);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(52, 57);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 4);
			LeaveRule("assignment", 4);
			LeaveRule_assignment();
		}
		DebugLocation(53, 4);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_ifstatement();
	partial void LeaveRule_ifstatement();

	// $ANTLR start "ifstatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:55:1: ifstatement : IF LPAREN ! expression RPAREN ! THEN ! blockstatement ( ELSE ! blockstatement ) ;
	[GrammarRule("ifstatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> ifstatement()
	{
		EnterRule_ifstatement();
		EnterRule("ifstatement", 5);
		TraceIn("ifstatement", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IF21 = default(IToken);
		IToken LPAREN22 = default(IToken);
		IToken RPAREN24 = default(IToken);
		IToken THEN25 = default(IToken);
		IToken ELSE27 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement26 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement28 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IF21_tree = default(CommonTree);
		CommonTree LPAREN22_tree = default(CommonTree);
		CommonTree RPAREN24_tree = default(CommonTree);
		CommonTree THEN25_tree = default(CommonTree);
		CommonTree ELSE27_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "ifstatement");
		DebugLocation(55, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:56:5: ( IF LPAREN ! expression RPAREN ! THEN ! blockstatement ( ELSE ! blockstatement ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:57:5: IF LPAREN ! expression RPAREN ! THEN ! blockstatement ( ELSE ! blockstatement )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(57, 5);
			IF21=(IToken)Match(input,IF,Follow._IF_in_ifstatement303); if (state.failed) return retval;
			if (state.backtracking == 0) {
			IF21_tree = (CommonTree)adaptor.Create(IF21);
			adaptor.AddChild(root_0, IF21_tree);
			}
			DebugLocation(57, 14);
			LPAREN22=(IToken)Match(input,LPAREN,Follow._LPAREN_in_ifstatement305); if (state.failed) return retval;
			DebugLocation(57, 16);
			PushFollow(Follow._expression_in_ifstatement308);
			expression23=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression23.Tree);
			DebugLocation(57, 33);
			RPAREN24=(IToken)Match(input,RPAREN,Follow._RPAREN_in_ifstatement310); if (state.failed) return retval;
			DebugLocation(57, 39);
			THEN25=(IToken)Match(input,THEN,Follow._THEN_in_ifstatement313); if (state.failed) return retval;
			DebugLocation(58, 9);
			PushFollow(Follow._blockstatement_in_ifstatement325);
			blockstatement26=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement26.Tree);
			DebugLocation(59, 5);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:59:5: ( ELSE ! blockstatement )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:60:9: ELSE ! blockstatement
			{
			DebugLocation(60, 13);
			ELSE27=(IToken)Match(input,ELSE,Follow._ELSE_in_ifstatement342); if (state.failed) return retval;
			DebugLocation(61, 9);
			PushFollow(Follow._blockstatement_in_ifstatement354);
			blockstatement28=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement28.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifstatement", 5);
			LeaveRule("ifstatement", 5);
			LeaveRule_ifstatement();
		}
		DebugLocation(63, 4);
		} finally { DebugExitRule(GrammarFileName, "ifstatement"); }
		return retval;

	}
	// $ANTLR end "ifstatement"

	partial void EnterRule_whilestatement();
	partial void LeaveRule_whilestatement();

	// $ANTLR start "whilestatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:65:1: whilestatement : WHILE LPAREN ! expression RPAREN ! blockstatement ;
	[GrammarRule("whilestatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> whilestatement()
	{
		EnterRule_whilestatement();
		EnterRule("whilestatement", 6);
		TraceIn("whilestatement", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WHILE29 = default(IToken);
		IToken LPAREN30 = default(IToken);
		IToken RPAREN32 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression31 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement33 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WHILE29_tree = default(CommonTree);
		CommonTree LPAREN30_tree = default(CommonTree);
		CommonTree RPAREN32_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "whilestatement");
		DebugLocation(65, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:66:5: ( WHILE LPAREN ! expression RPAREN ! blockstatement )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:67:5: WHILE LPAREN ! expression RPAREN ! blockstatement
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(67, 5);
			WHILE29=(IToken)Match(input,WHILE,Follow._WHILE_in_whilestatement383); if (state.failed) return retval;
			if (state.backtracking == 0) {
			WHILE29_tree = (CommonTree)adaptor.Create(WHILE29);
			adaptor.AddChild(root_0, WHILE29_tree);
			}
			DebugLocation(67, 17);
			LPAREN30=(IToken)Match(input,LPAREN,Follow._LPAREN_in_whilestatement385); if (state.failed) return retval;
			DebugLocation(67, 19);
			PushFollow(Follow._expression_in_whilestatement388);
			expression31=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression31.Tree);
			DebugLocation(67, 36);
			RPAREN32=(IToken)Match(input,RPAREN,Follow._RPAREN_in_whilestatement390); if (state.failed) return retval;
			DebugLocation(67, 38);
			PushFollow(Follow._blockstatement_in_whilestatement393);
			blockstatement33=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement33.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whilestatement", 6);
			LeaveRule("whilestatement", 6);
			LeaveRule_whilestatement();
		}
		DebugLocation(68, 4);
		} finally { DebugExitRule(GrammarFileName, "whilestatement"); }
		return retval;

	}
	// $ANTLR end "whilestatement"

	partial void EnterRule_returnstatement();
	partial void LeaveRule_returnstatement();

	// $ANTLR start "returnstatement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:70:1: returnstatement : RETURN expression ;
	[GrammarRule("returnstatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> returnstatement()
	{
		EnterRule_returnstatement();
		EnterRule("returnstatement", 7);
		TraceIn("returnstatement", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken RETURN34 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression35 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree RETURN34_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "returnstatement");
		DebugLocation(70, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:71:5: ( RETURN expression )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:71:7: RETURN expression
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(71, 7);
			RETURN34=(IToken)Match(input,RETURN,Follow._RETURN_in_returnstatement410); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RETURN34_tree = (CommonTree)adaptor.Create(RETURN34);
			adaptor.AddChild(root_0, RETURN34_tree);
			}
			DebugLocation(71, 14);
			PushFollow(Follow._expression_in_returnstatement412);
			expression35=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression35.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("returnstatement", 7);
			LeaveRule("returnstatement", 7);
			LeaveRule_returnstatement();
		}
		DebugLocation(72, 4);
		} finally { DebugExitRule(GrammarFileName, "returnstatement"); }
		return retval;

	}
	// $ANTLR end "returnstatement"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:74:1: statement : ( assignment | ifstatement | returnstatement | whilestatement | blockstatement ) SEMI !;
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 8);
		TraceIn("statement", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken SEMI41 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignment36 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifstatement37 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> returnstatement38 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> whilestatement39 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement40 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI41_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(74, 9);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:75:5: ( ( assignment | ifstatement | returnstatement | whilestatement | blockstatement ) SEMI !)
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:76:5: ( assignment | ifstatement | returnstatement | whilestatement | blockstatement ) SEMI !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(76, 5);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:76:5: ( assignment | ifstatement | returnstatement | whilestatement | blockstatement )
			int alt4=5;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case IDENTIFIER:
				{
				alt4 = 1;
				}
				break;
			case IF:
				{
				alt4 = 2;
				}
				break;
			case RETURN:
				{
				alt4 = 3;
				}
				break;
			case WHILE:
				{
				alt4 = 4;
				}
				break;
			case LCURLY:
				{
				alt4 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:77:7: assignment
				{
				DebugLocation(77, 7);
				PushFollow(Follow._assignment_in_statement445);
				assignment36=assignment();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignment36.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:78:7: ifstatement
				{
				DebugLocation(78, 7);
				PushFollow(Follow._ifstatement_in_statement454);
				ifstatement37=ifstatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifstatement37.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:79:7: returnstatement
				{
				DebugLocation(79, 7);
				PushFollow(Follow._returnstatement_in_statement462);
				returnstatement38=returnstatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, returnstatement38.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:80:7: whilestatement
				{
				DebugLocation(80, 7);
				PushFollow(Follow._whilestatement_in_statement470);
				whilestatement39=whilestatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, whilestatement39.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:81:7: blockstatement
				{
				DebugLocation(81, 7);
				PushFollow(Follow._blockstatement_in_statement478);
				blockstatement40=blockstatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement40.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(83, 9);
			SEMI41=(IToken)Match(input,SEMI,Follow._SEMI_in_statement498); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 8);
			LeaveRule("statement", 8);
			LeaveRule_statement();
		}
		DebugLocation(83, 9);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_funcdecl();
	partial void LeaveRule_funcdecl();

	// $ANTLR start "funcdecl"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:85:1: funcdecl : DECLARE FUNCTION COLON IDENTIFIER LPAREN ( IDENTIFIER ( COMMA IDENTIFIER )* )? RPAREN blockstatement -> ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement ) ;
	[GrammarRule("funcdecl")]
	private AstParserRuleReturnScope<CommonTree, IToken> funcdecl()
	{
		EnterRule_funcdecl();
		EnterRule("funcdecl", 9);
		TraceIn("funcdecl", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DECLARE42 = default(IToken);
		IToken FUNCTION43 = default(IToken);
		IToken COLON44 = default(IToken);
		IToken IDENTIFIER45 = default(IToken);
		IToken LPAREN46 = default(IToken);
		IToken IDENTIFIER47 = default(IToken);
		IToken COMMA48 = default(IToken);
		IToken IDENTIFIER49 = default(IToken);
		IToken RPAREN50 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement51 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DECLARE42_tree = default(CommonTree);
		CommonTree FUNCTION43_tree = default(CommonTree);
		CommonTree COLON44_tree = default(CommonTree);
		CommonTree IDENTIFIER45_tree = default(CommonTree);
		CommonTree LPAREN46_tree = default(CommonTree);
		CommonTree IDENTIFIER47_tree = default(CommonTree);
		CommonTree COMMA48_tree = default(CommonTree);
		CommonTree IDENTIFIER49_tree = default(CommonTree);
		CommonTree RPAREN50_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_DECLARE=new RewriteRuleITokenStream(adaptor,"token DECLARE");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_blockstatement=new RewriteRuleSubtreeStream(adaptor,"rule blockstatement");
		try { DebugEnterRule(GrammarFileName, "funcdecl");
		DebugLocation(85, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:86:5: ( DECLARE FUNCTION COLON IDENTIFIER LPAREN ( IDENTIFIER ( COMMA IDENTIFIER )* )? RPAREN blockstatement -> ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:87:5: DECLARE FUNCTION COLON IDENTIFIER LPAREN ( IDENTIFIER ( COMMA IDENTIFIER )* )? RPAREN blockstatement
			{
			DebugLocation(87, 5);
			DECLARE42=(IToken)Match(input,DECLARE,Follow._DECLARE_in_funcdecl517); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DECLARE.Add(DECLARE42);

			DebugLocation(87, 13);
			FUNCTION43=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_funcdecl519); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION43);

			DebugLocation(87, 22);
			COLON44=(IToken)Match(input,COLON,Follow._COLON_in_funcdecl521); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON44);

			DebugLocation(87, 28);
			IDENTIFIER45=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl523); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER45);

			DebugLocation(87, 39);
			LPAREN46=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funcdecl525); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN46);

			DebugLocation(87, 46);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:87:46: ( IDENTIFIER ( COMMA IDENTIFIER )* )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==IDENTIFIER))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:87:47: IDENTIFIER ( COMMA IDENTIFIER )*
				{
				DebugLocation(87, 47);
				IDENTIFIER47=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl528); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER47);

				DebugLocation(87, 58);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:87:58: ( COMMA IDENTIFIER )*
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if ((LA5_0==COMMA))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch ( alt5 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:87:59: COMMA IDENTIFIER
						{
						DebugLocation(87, 59);
						COMMA48=(IToken)Match(input,COMMA,Follow._COMMA_in_funcdecl531); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA48);

						DebugLocation(87, 65);
						IDENTIFIER49=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl533); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER49);


						}
						break;

					default:
						goto loop5;
					}
				}

				loop5:
					;

				} finally { DebugExitSubRule(5); }


				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(87, 80);
			RPAREN50=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funcdecl539); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN50);

			DebugLocation(87, 87);
			PushFollow(Follow._blockstatement_in_funcdecl541);
			blockstatement51=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_blockstatement.Add(blockstatement51.Tree);


			{
			// AST REWRITE
			// elements: blockstatement, IDENTIFIER, IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 87:102: -> ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement )
			{
				DebugLocation(87, 105);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:87:105: ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(87, 107);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNCDECL, "FUNCDECL"), root_1);

				DebugLocation(87, 116);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(87, 127);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:87:127: ( IDENTIFIER )*
				while ( stream_IDENTIFIER.HasNext )
				{
					DebugLocation(87, 127);
					adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());

				}
				stream_IDENTIFIER.Reset();
				DebugLocation(87, 139);
				adaptor.AddChild(root_1, stream_blockstatement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcdecl", 9);
			LeaveRule("funcdecl", 9);
			LeaveRule_funcdecl();
		}
		DebugLocation(88, 4);
		} finally { DebugExitRule(GrammarFileName, "funcdecl"); }
		return retval;

	}
	// $ANTLR end "funcdecl"

	partial void EnterRule_funccall();
	partial void LeaveRule_funccall();

	// $ANTLR start "funccall"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:90:1: funccall : CALL IDENTIFIER LPAREN ( expression ( COMMA expression )* )? RPAREN -> ^( CALL IDENTIFIER ( expression )* ) ;
	[GrammarRule("funccall")]
	private AstParserRuleReturnScope<CommonTree, IToken> funccall()
	{
		EnterRule_funccall();
		EnterRule("funccall", 10);
		TraceIn("funccall", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken CALL52 = default(IToken);
		IToken IDENTIFIER53 = default(IToken);
		IToken LPAREN54 = default(IToken);
		IToken COMMA56 = default(IToken);
		IToken RPAREN58 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression55 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression57 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CALL52_tree = default(CommonTree);
		CommonTree IDENTIFIER53_tree = default(CommonTree);
		CommonTree LPAREN54_tree = default(CommonTree);
		CommonTree COMMA56_tree = default(CommonTree);
		CommonTree RPAREN58_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_CALL=new RewriteRuleITokenStream(adaptor,"token CALL");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "funccall");
		DebugLocation(90, 97);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:91:5: ( CALL IDENTIFIER LPAREN ( expression ( COMMA expression )* )? RPAREN -> ^( CALL IDENTIFIER ( expression )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:92:1: CALL IDENTIFIER LPAREN ( expression ( COMMA expression )* )? RPAREN
			{
			DebugLocation(92, 1);
			CALL52=(IToken)Match(input,CALL,Follow._CALL_in_funccall573); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CALL.Add(CALL52);

			DebugLocation(92, 6);
			IDENTIFIER53=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funccall575); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER53);

			DebugLocation(92, 17);
			LPAREN54=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funccall577); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN54);

			DebugLocation(92, 24);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:92:24: ( expression ( COMMA expression )* )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==CALL||LA8_0==FLOAT||LA8_0==IDENTIFIER||LA8_0==INT||LA8_0==LPAREN||LA8_0==NEGATE))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:92:25: expression ( COMMA expression )*
				{
				DebugLocation(92, 25);
				PushFollow(Follow._expression_in_funccall580);
				expression55=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression55.Tree);
				DebugLocation(92, 36);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:92:36: ( COMMA expression )*
				try { DebugEnterSubRule(7);
				while (true)
				{
					int alt7=2;
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0==COMMA))
					{
						alt7 = 1;
					}


					} finally { DebugExitDecision(7); }
					switch ( alt7 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:92:37: COMMA expression
						{
						DebugLocation(92, 37);
						COMMA56=(IToken)Match(input,COMMA,Follow._COMMA_in_funccall583); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA56);

						DebugLocation(92, 43);
						PushFollow(Follow._expression_in_funccall585);
						expression57=expression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expression.Add(expression57.Tree);

						}
						break;

					default:
						goto loop7;
					}
				}

				loop7:
					;

				} finally { DebugExitSubRule(7); }


				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(92, 58);
			RPAREN58=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funccall591); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN58);



			{
			// AST REWRITE
			// elements: expression, IDENTIFIER, CALL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 92:65: -> ^( CALL IDENTIFIER ( expression )* )
			{
				DebugLocation(92, 68);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:92:68: ^( CALL IDENTIFIER ( expression )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(92, 70);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_CALL.NextNode(), root_1);

				DebugLocation(92, 75);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(92, 86);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:92:86: ( expression )*
				while ( stream_expression.HasNext )
				{
					DebugLocation(92, 86);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funccall", 10);
			LeaveRule("funccall", 10);
			LeaveRule_funccall();
		}
		DebugLocation(92, 97);
		} finally { DebugExitRule(GrammarFileName, "funccall"); }
		return retval;

	}
	// $ANTLR end "funccall"

	partial void EnterRule_primary();
	partial void LeaveRule_primary();

	// $ANTLR start "primary"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:95:1: primary : ( INT | FLOAT | IDENTIFIER -> ^( VAR IDENTIFIER ) | funccall | LPAREN ! expression RPAREN !);
	[GrammarRule("primary")]
	private AstParserRuleReturnScope<CommonTree, IToken> primary()
	{
		EnterRule_primary();
		EnterRule("primary", 11);
		TraceIn("primary", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INT59 = default(IToken);
		IToken FLOAT60 = default(IToken);
		IToken IDENTIFIER61 = default(IToken);
		IToken LPAREN63 = default(IToken);
		IToken RPAREN65 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> funccall62 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression64 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INT59_tree = default(CommonTree);
		CommonTree FLOAT60_tree = default(CommonTree);
		CommonTree IDENTIFIER61_tree = default(CommonTree);
		CommonTree LPAREN63_tree = default(CommonTree);
		CommonTree RPAREN65_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		try { DebugEnterRule(GrammarFileName, "primary");
		DebugLocation(95, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:96:5: ( INT | FLOAT | IDENTIFIER -> ^( VAR IDENTIFIER ) | funccall | LPAREN ! expression RPAREN !)
			int alt9=5;
			try { DebugEnterDecision(9, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt9 = 1;
				}
				break;
			case FLOAT:
				{
				alt9 = 2;
				}
				break;
			case IDENTIFIER:
				{
				alt9 = 3;
				}
				break;
			case CALL:
				{
				alt9 = 4;
				}
				break;
			case LPAREN:
				{
				alt9 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:96:7: INT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(96, 7);
				INT59=(IToken)Match(input,INT,Follow._INT_in_primary624); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INT59_tree = (CommonTree)adaptor.Create(INT59);
				adaptor.AddChild(root_0, INT59_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:97:7: FLOAT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(97, 7);
				FLOAT60=(IToken)Match(input,FLOAT,Follow._FLOAT_in_primary633); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FLOAT60_tree = (CommonTree)adaptor.Create(FLOAT60);
				adaptor.AddChild(root_0, FLOAT60_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:98:7: IDENTIFIER
				{
				DebugLocation(98, 7);
				IDENTIFIER61=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_primary641); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER61);



				{
				// AST REWRITE
				// elements: IDENTIFIER
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 98:18: -> ^( VAR IDENTIFIER )
				{
					DebugLocation(98, 21);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:98:21: ^( VAR IDENTIFIER )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(98, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VAR, "VAR"), root_1);

					DebugLocation(98, 27);
					adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:99:7: funccall
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(99, 7);
				PushFollow(Follow._funccall_in_primary657);
				funccall62=funccall();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funccall62.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:100:7: LPAREN ! expression RPAREN !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(100, 13);
				LPAREN63=(IToken)Match(input,LPAREN,Follow._LPAREN_in_primary665); if (state.failed) return retval;
				DebugLocation(100, 15);
				PushFollow(Follow._expression_in_primary668);
				expression64=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression64.Tree);
				DebugLocation(100, 32);
				RPAREN65=(IToken)Match(input,RPAREN,Follow._RPAREN_in_primary670); if (state.failed) return retval;

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primary", 11);
			LeaveRule("primary", 11);
			LeaveRule_primary();
		}
		DebugLocation(101, 4);
		} finally { DebugExitRule(GrammarFileName, "primary"); }
		return retval;

	}
	// $ANTLR end "primary"

	partial void EnterRule_unaryexpr();
	partial void LeaveRule_unaryexpr();

	// $ANTLR start "unaryexpr"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:103:1: unaryexpr : ( NEGATE )* primary ;
	[GrammarRule("unaryexpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> unaryexpr()
	{
		EnterRule_unaryexpr();
		EnterRule("unaryexpr", 12);
		TraceIn("unaryexpr", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NEGATE66 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> primary67 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NEGATE66_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unaryexpr");
		DebugLocation(103, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:104:5: ( ( NEGATE )* primary )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:104:7: ( NEGATE )* primary
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(104, 7);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:104:7: ( NEGATE )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==NEGATE))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:104:8: NEGATE
					{
					DebugLocation(104, 8);
					NEGATE66=(IToken)Match(input,NEGATE,Follow._NEGATE_in_unaryexpr689); if (state.failed) return retval;
					if (state.backtracking == 0) {
					NEGATE66_tree = (CommonTree)adaptor.Create(NEGATE66);
					adaptor.AddChild(root_0, NEGATE66_tree);
					}

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(104, 17);
			PushFollow(Follow._primary_in_unaryexpr693);
			primary67=primary();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primary67.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryexpr", 12);
			LeaveRule("unaryexpr", 12);
			LeaveRule_unaryexpr();
		}
		DebugLocation(105, 4);
		} finally { DebugExitRule(GrammarFileName, "unaryexpr"); }
		return retval;

	}
	// $ANTLR end "unaryexpr"

	partial void EnterRule_multexpr();
	partial void LeaveRule_multexpr();

	// $ANTLR start "multexpr"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:107:1: multexpr : unaryexpr ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )* ;
	[GrammarRule("multexpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> multexpr()
	{
		EnterRule_multexpr();
		EnterRule("multexpr", 13);
		TraceIn("multexpr", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set69 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unaryexpr68 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryexpr70 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set69_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multexpr");
		DebugLocation(107, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:108:5: ( unaryexpr ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )* )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:108:7: unaryexpr ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(108, 7);
			PushFollow(Follow._unaryexpr_in_multexpr720);
			unaryexpr68=unaryexpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, unaryexpr68.Tree);
			DebugLocation(108, 17);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:108:17: ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==DIVIDE||LA11_0==MULTIPLY))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:108:18: ( MULTIPLY | DIVIDE ) ^ unaryexpr
					{
					DebugLocation(108, 35);

					set69=(IToken)input.LT(1);
					set69=(IToken)input.LT(1);
					if (input.LA(1)==DIVIDE||input.LA(1)==MULTIPLY)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set69), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(108, 37);
					PushFollow(Follow._unaryexpr_in_multexpr730);
					unaryexpr70=unaryexpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, unaryexpr70.Tree);

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multexpr", 13);
			LeaveRule("multexpr", 13);
			LeaveRule_multexpr();
		}
		DebugLocation(109, 4);
		} finally { DebugExitRule(GrammarFileName, "multexpr"); }
		return retval;

	}
	// $ANTLR end "multexpr"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:112:1: expression : multexpr ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 14);
		TraceIn("expression", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set72 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> multexpr71 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> multexpr73 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set72_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(112, 4);
		try
		{
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:113:5: ( multexpr ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )* )
			DebugEnterAlt(1);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:113:7: multexpr ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(113, 7);
			PushFollow(Follow._multexpr_in_expression755);
			multexpr71=multexpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, multexpr71.Tree);
			DebugLocation(113, 16);
			// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:113:16: ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==AND||LA12_0==EQUALS||(LA12_0>=GT && LA12_0<=GTEQ)||(LA12_0>=LT && LA12_0<=MINUS)||(LA12_0>=OR && LA12_0<=PLUS)))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\vorsters.SFTREAL\\workspace\\ANTLR-MyLanguage\\src\\PlayingWithDLR\\MyScriptRuntime\\MyLangParser.g:113:17: ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr
					{
					DebugLocation(113, 59);

					set72=(IToken)input.LT(1);
					set72=(IToken)input.LT(1);
					if (input.LA(1)==AND||input.LA(1)==EQUALS||(input.LA(1)>=GT && input.LA(1)<=GTEQ)||(input.LA(1)>=LT && input.LA(1)<=MINUS)||(input.LA(1)>=OR && input.LA(1)<=PLUS))
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set72), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(113, 61);
					PushFollow(Follow._multexpr_in_expression779);
					multexpr73=multexpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multexpr73.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 14);
			LeaveRule("expression", 14);
			LeaveRule_expression();
		}
		DebugLocation(114, 4);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _RUN_in_runprogram141 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _PROGRAM_in_runprogram143 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_runprogram145 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_runprogram147 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DECLARE_in_program176 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _PROGRAM_in_program178 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_program180 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_program182 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _LCURLY_in_program184 = new BitSet(new ulong[]{0x20000800UL});
		public static readonly BitSet _funcdecl_in_program186 = new BitSet(new ulong[]{0x20000800UL});
		public static readonly BitSet _blockstatement_in_program189 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _RCURLY_in_program191 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ENDP_in_program195 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOF_in_program201 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_blockstatement229 = new BitSet(new ulong[]{0x4030026000000UL});
		public static readonly BitSet _statement_in_blockstatement231 = new BitSet(new ulong[]{0x4030026000000UL});
		public static readonly BitSet _RCURLY_in_blockstatement234 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_assignment265 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_assignment267 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_assignment269 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_ifstatement303 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_ifstatement305 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_ifstatement308 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _RPAREN_in_ifstatement310 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _THEN_in_ifstatement313 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_ifstatement325 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _ELSE_in_ifstatement342 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_ifstatement354 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_whilestatement383 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_whilestatement385 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_whilestatement388 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _RPAREN_in_whilestatement390 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_whilestatement393 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_returnstatement410 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_returnstatement412 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignment_in_statement445 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _ifstatement_in_statement454 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _returnstatement_in_statement462 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _whilestatement_in_statement470 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _blockstatement_in_statement478 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _SEMI_in_statement498 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DECLARE_in_funcdecl517 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _FUNCTION_in_funcdecl519 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_funcdecl521 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl523 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_funcdecl525 = new BitSet(new ulong[]{0x40002000000UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl528 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _COMMA_in_funcdecl531 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl533 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _RPAREN_in_funcdecl539 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_funcdecl541 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CALL_in_funccall573 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_funccall575 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_funccall577 = new BitSet(new ulong[]{0x4084A080080UL});
		public static readonly BitSet _expression_in_funccall580 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _COMMA_in_funccall583 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_funccall585 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _RPAREN_in_funccall591 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_primary624 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_primary633 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_primary641 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funccall_in_primary657 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_primary665 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _expression_in_primary668 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _RPAREN_in_primary670 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEGATE_in_unaryexpr689 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _primary_in_unaryexpr693 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryexpr_in_multexpr720 = new BitSet(new ulong[]{0x400002002UL});
		public static readonly BitSet _set_in_multexpr723 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _unaryexpr_in_multexpr730 = new BitSet(new ulong[]{0x400002002UL});
		public static readonly BitSet _multexpr_in_expression755 = new BitSet(new ulong[]{0x3381820012UL});
		public static readonly BitSet _set_in_expression758 = new BitSet(new ulong[]{0x84A080080UL});
		public static readonly BitSet _multexpr_in_expression779 = new BitSet(new ulong[]{0x3381820012UL});
	}
	#endregion Follow sets
}

} // namespace  PlayingWithDLR.MyScriptRuntime.Script 
