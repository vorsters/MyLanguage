//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g 2016-10-24 08:35:39

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


  //using System.Collections.Generic;
  
  using System;
  using MyLanguageImpl.Runtime;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  MyLanguageImpl.Grammar 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class MyLangTree : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ASSIGN", "BLOCKSTMT", "CALL", "COLON", "COMMA", "COMMENT", "DECLARE", "DIGIT", "DIVIDE", "DOT", "ELSE", "ENDP", "EQUALS", "EXPONENT", "FLOAT", "FUNCCALL", "FUNCDECL", "FUNCTION", "GT", "GTEQ", "IDENTIFIER", "IF", "INT", "LCLETTER", "LCURLY", "LPAREN", "LT", "LTEQ", "MINUS", "MULTIPLY", "NEGATE", "OR", "PLUS", "PROGDECL", "PROGRAM", "RCURLY", "RETURN", "RPAREN", "RUN", "RUNPROG", "SEMI", "THEN", "UCLETTER", "USCORE", "VAR", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int ASSIGN=5;
	public const int BLOCKSTMT=6;
	public const int CALL=7;
	public const int COLON=8;
	public const int COMMA=9;
	public const int COMMENT=10;
	public const int DECLARE=11;
	public const int DIGIT=12;
	public const int DIVIDE=13;
	public const int DOT=14;
	public const int ELSE=15;
	public const int ENDP=16;
	public const int EQUALS=17;
	public const int EXPONENT=18;
	public const int FLOAT=19;
	public const int FUNCCALL=20;
	public const int FUNCDECL=21;
	public const int FUNCTION=22;
	public const int GT=23;
	public const int GTEQ=24;
	public const int IDENTIFIER=25;
	public const int IF=26;
	public const int INT=27;
	public const int LCLETTER=28;
	public const int LCURLY=29;
	public const int LPAREN=30;
	public const int LT=31;
	public const int LTEQ=32;
	public const int MINUS=33;
	public const int MULTIPLY=34;
	public const int NEGATE=35;
	public const int OR=36;
	public const int PLUS=37;
	public const int PROGDECL=38;
	public const int PROGRAM=39;
	public const int RCURLY=40;
	public const int RETURN=41;
	public const int RPAREN=42;
	public const int RUN=43;
	public const int RUNPROG=44;
	public const int SEMI=45;
	public const int THEN=46;
	public const int UCLETTER=47;
	public const int USCORE=48;
	public const int VAR=49;
	public const int WHILE=50;
	public const int WS=51;

	public MyLangTree(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public MyLangTree(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return MyLangTree.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_runprogram();
	partial void LeaveRule_runprogram();

	// $ANTLR start "runprogram"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:21:1: runprogram returns [MyRunProgramNode result] : ^( RUNPROG progname= IDENTIFIER ) ;
	[GrammarRule("runprogram")]
	private MyRunProgramNode runprogram()
	{
		EnterRule_runprogram();
		EnterRule("runprogram", 1);
		TraceIn("runprogram", 1);
		MyRunProgramNode result = default(MyRunProgramNode);


		CommonTree progname = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "runprogram");
		DebugLocation(21, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:22:5: ( ^( RUNPROG progname= IDENTIFIER ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:23:5: ^( RUNPROG progname= IDENTIFIER )
			{
			DebugLocation(23, 5);
			DebugLocation(23, 7);
			Match(input,RUNPROG,Follow._RUNPROG_in_runprogram88); if (state.failed) return result;

			Match(input, TokenTypes.Down, null); if (state.failed) return result;
			DebugLocation(23, 23);
			progname=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_runprogram92); if (state.failed) return result;

			Match(input, TokenTypes.Up, null); if (state.failed) return result;

			DebugLocation(23, 36);
			if (state.backtracking == 0)
			{
				result = new MyRunProgramNode(progname.Text);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("runprogram", 1);
			LeaveRule("runprogram", 1);
			LeaveRule_runprogram();
		}
		DebugLocation(24, 4);
		} finally { DebugExitRule(GrammarFileName, "runprogram"); }
		return result;

	}
	// $ANTLR end "runprogram"

	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:26:8: public program returns [MyProgramDeclNode result] : ^( PROGDECL progname= identifier ( (f= funcdecl )* ) bs= blockstatement ) ;
	[GrammarRule("program")]
	public MyProgramDeclNode program()
	{
		EnterRule_program();
		EnterRule("program", 2);
		TraceIn("program", 2);
		MyProgramDeclNode result = default(MyProgramDeclNode);


		string progname = default(string);
		MyFunctionDecleration f = default(MyFunctionDecleration);
		MyStatementListNode bs = default(MyStatementListNode);

			    	
					List<MyFunctionDecleration> funcs = new List<MyFunctionDecleration>();
					string programName = String.Empty;
					MyStatementListNode statementListNode = null;
				
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(26, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:37:5: ( ^( PROGDECL progname= identifier ( (f= funcdecl )* ) bs= blockstatement ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:38:5: ^( PROGDECL progname= identifier ( (f= funcdecl )* ) bs= blockstatement )
			{
			DebugLocation(38, 5);
			DebugLocation(38, 7);
			Match(input,PROGDECL,Follow._PROGDECL_in_program150); if (state.failed) return result;

			Match(input, TokenTypes.Down, null); if (state.failed) return result;
			DebugLocation(38, 24);
			PushFollow(Follow._identifier_in_program154);
			progname=identifier();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(38, 36);
			if (state.backtracking == 0)
			{
				programName = progname;
			}
			DebugLocation(39, 7);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:39:7: ( (f= funcdecl )* )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:39:8: (f= funcdecl )*
			{
			DebugLocation(39, 8);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:39:8: (f= funcdecl )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==FUNCDECL))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:39:9: f= funcdecl
					{
					DebugLocation(39, 10);
					PushFollow(Follow._funcdecl_in_program168);
					f=funcdecl();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(39, 20);
					if (state.backtracking == 0)
					{
						funcs.Add(f);
					}

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			DebugLocation(39, 41);
			PushFollow(Follow._blockstatement_in_program177);
			bs=blockstatement();
			PopFollow();
			if (state.failed) return result;

			Match(input, TokenTypes.Up, null); if (state.failed) return result;

			DebugLocation(39, 58);
			if (state.backtracking == 0)
			{
				statementListNode=bs;
			}

			}

			if (state.backtracking == 0)
			{

				            result = new MyProgramDeclNode(programName, funcs, statementListNode);
					    
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 2);
			LeaveRule("program", 2);
			LeaveRule_program();
		}
		DebugLocation(40, 4);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return result;

	}
	// $ANTLR end "program"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();

	// $ANTLR start "identifier"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:42:1: identifier returns [string result] : n= IDENTIFIER ;
	[GrammarRule("identifier")]
	private string identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 3);
		TraceIn("identifier", 3);
		string result = default(string);


		CommonTree n = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(42, 1);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:43:2: (n= IDENTIFIER )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:44:2: n= IDENTIFIER
			{
			DebugLocation(44, 3);
			n=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_identifier205); if (state.failed) return result;
			DebugLocation(44, 15);
			if (state.backtracking == 0)
			{
				result = n.Text;
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("identifier", 3);
			LeaveRule("identifier", 3);
			LeaveRule_identifier();
		}
		DebugLocation(45, 1);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return result;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_blockstatement();
	partial void LeaveRule_blockstatement();

	// $ANTLR start "blockstatement"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:47:1: blockstatement returns [MyStatementListNode result] : ^( BLOCKSTMT (st= statement )* ) ;
	[GrammarRule("blockstatement")]
	private MyStatementListNode blockstatement()
	{
		EnterRule_blockstatement();
		EnterRule("blockstatement", 4);
		TraceIn("blockstatement", 4);
		MyStatementListNode result = default(MyStatementListNode);


		MyStatementNode st = default(MyStatementNode);


					result = new MyStatementListNode();
					int j = 0;
				
		try { DebugEnterRule(GrammarFileName, "blockstatement");
		DebugLocation(47, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:56:5: ( ^( BLOCKSTMT (st= statement )* ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:56:7: ^( BLOCKSTMT (st= statement )* )
			{
			DebugLocation(56, 7);
			DebugLocation(56, 9);
			Match(input,BLOCKSTMT,Follow._BLOCKSTMT_in_blockstatement251); if (state.failed) return result;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(57, 6);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:57:6: (st= statement )*
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_0 = input.LA(1);

					if (((LA2_0>=ASSIGN && LA2_0<=BLOCKSTMT)||LA2_0==IF||LA2_0==RETURN||LA2_0==WHILE))
					{
						alt2 = 1;
					}


					} finally { DebugExitDecision(2); }
					switch ( alt2 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:57:7: st= statement
						{
						DebugLocation(57, 10);
						PushFollow(Follow._statement_in_blockstatement264);
						st=statement();
						PopFollow();
						if (state.failed) return result;
						DebugLocation(57, 22);
						if (state.backtracking == 0)
						{
							 result.AddStatement(st); 
						}

						}
						break;

					default:
						goto loop2;
					}
				}

				loop2:
					;

				} finally { DebugExitSubRule(2); }

				DebugLocation(57, 55);
				if (state.backtracking == 0)
				{
					j++;
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;
			}


			}

			if (state.backtracking == 0)
			{

						
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("blockstatement", 4);
			LeaveRule("blockstatement", 4);
			LeaveRule_blockstatement();
		}
		DebugLocation(58, 4);
		} finally { DebugExitRule(GrammarFileName, "blockstatement"); }
		return result;

	}
	// $ANTLR end "blockstatement"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();

	// $ANTLR start "assignment"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:60:1: assignment returns [MyAssignmentNode result] : ^( ASSIGN IDENTIFIER e= expression ) ;
	[GrammarRule("assignment")]
	private MyAssignmentNode assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 5);
		TraceIn("assignment", 5);
		MyAssignmentNode result = default(MyAssignmentNode);


		CommonTree IDENTIFIER1 = default(CommonTree);
		MyAbstractNode e = default(MyAbstractNode);

		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(60, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:61:5: ( ^( ASSIGN IDENTIFIER e= expression ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:61:7: ^( ASSIGN IDENTIFIER e= expression )
			{
			DebugLocation(61, 7);
			DebugLocation(61, 9);
			Match(input,ASSIGN,Follow._ASSIGN_in_assignment294); if (state.failed) return result;

			Match(input, TokenTypes.Down, null); if (state.failed) return result;
			DebugLocation(61, 16);
			IDENTIFIER1=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_assignment296); if (state.failed) return result;
			DebugLocation(61, 28);
			PushFollow(Follow._expression_in_assignment300);
			e=expression();
			PopFollow();
			if (state.failed) return result;

			Match(input, TokenTypes.Up, null); if (state.failed) return result;

			DebugLocation(62, 9);
			if (state.backtracking == 0)
			{

				            MyVariableNode v = new MyVariableNode(IDENTIFIER1.Text);
				            result = new MyAssignmentNode(v,e);
				        
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assignment", 5);
			LeaveRule("assignment", 5);
			LeaveRule_assignment();
		}
		DebugLocation(66, 4);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return result;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_ifstatement();
	partial void LeaveRule_ifstatement();

	// $ANTLR start "ifstatement"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:68:1: ifstatement returns [MyIfStatement result] : IF condition= expression thenpart= blockstatement ( (elsepart= blockstatement )? ) ;
	[GrammarRule("ifstatement")]
	private MyIfStatement ifstatement()
	{
		EnterRule_ifstatement();
		EnterRule("ifstatement", 6);
		TraceIn("ifstatement", 6);
		MyIfStatement result = default(MyIfStatement);


		MyAbstractNode condition = default(MyAbstractNode);
		MyStatementListNode thenpart = default(MyStatementListNode);
		MyStatementListNode elsepart = default(MyStatementListNode);

		try { DebugEnterRule(GrammarFileName, "ifstatement");
		DebugLocation(68, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:69:5: ( IF condition= expression thenpart= blockstatement ( (elsepart= blockstatement )? ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:70:5: IF condition= expression thenpart= blockstatement ( (elsepart= blockstatement )? )
			{
			DebugLocation(70, 5);
			Match(input,IF,Follow._IF_in_ifstatement338); if (state.failed) return result;
			DebugLocation(70, 17);
			PushFollow(Follow._expression_in_ifstatement342);
			condition=expression();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(70, 37);
			PushFollow(Follow._blockstatement_in_ifstatement346);
			thenpart=blockstatement();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(71, 6);
			if (state.backtracking == 0)
			{

				            result = new MyIfStatement(condition, thenpart);
				    	
			}
			DebugLocation(74, 6);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:74:6: ( (elsepart= blockstatement )? )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:74:7: (elsepart= blockstatement )?
			{
			DebugLocation(74, 16);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:74:16: (elsepart= blockstatement )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==BLOCKSTMT))
			{
				int LA3_1 = input.LA(2);

				if ((LA3_1==DOWN))
				{
					switch (input.LA(3))
					{
					case ASSIGN:
						{
						int LA3_9 = input.LA(4);

						if ((EvaluatePredicate(synpred3_MyLangTree_fragment)))
						{
							alt3 = 1;
						}
						}
						break;
					case IF:
						{
						int LA3_10 = input.LA(4);

						if ((EvaluatePredicate(synpred3_MyLangTree_fragment)))
						{
							alt3 = 1;
						}
						}
						break;
					case RETURN:
						{
						int LA3_11 = input.LA(4);

						if ((EvaluatePredicate(synpred3_MyLangTree_fragment)))
						{
							alt3 = 1;
						}
						}
						break;
					case WHILE:
						{
						int LA3_12 = input.LA(4);

						if ((EvaluatePredicate(synpred3_MyLangTree_fragment)))
						{
							alt3 = 1;
						}
						}
						break;
					case BLOCKSTMT:
						{
						int LA3_13 = input.LA(4);

						if ((EvaluatePredicate(synpred3_MyLangTree_fragment)))
						{
							alt3 = 1;
						}
						}
						break;
					case UP:
						{
						int LA3_14 = input.LA(4);

						if ((EvaluatePredicate(synpred3_MyLangTree_fragment)))
						{
							alt3 = 1;
						}
						}
						break;
					}

				}
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:74:16: elsepart= blockstatement
				{
				DebugLocation(74, 16);
				PushFollow(Follow._blockstatement_in_ifstatement366);
				elsepart=blockstatement();
				PopFollow();
				if (state.failed) return result;

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(74, 34);
			if (state.backtracking == 0)
			{
				result.ElsePart = elsepart;
			}

			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ifstatement", 6);
			LeaveRule("ifstatement", 6);
			LeaveRule_ifstatement();
		}
		DebugLocation(75, 4);
		} finally { DebugExitRule(GrammarFileName, "ifstatement"); }
		return result;

	}
	// $ANTLR end "ifstatement"

	partial void EnterRule_whilestatement();
	partial void LeaveRule_whilestatement();

	// $ANTLR start "whilestatement"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:77:1: whilestatement returns [MyWhileStatement result] : WHILE e= expression bs= blockstatement ;
	[GrammarRule("whilestatement")]
	private MyWhileStatement whilestatement()
	{
		EnterRule_whilestatement();
		EnterRule("whilestatement", 7);
		TraceIn("whilestatement", 7);
		MyWhileStatement result = default(MyWhileStatement);


		MyAbstractNode e = default(MyAbstractNode);
		MyStatementListNode bs = default(MyStatementListNode);

		try { DebugEnterRule(GrammarFileName, "whilestatement");
		DebugLocation(77, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:78:5: ( WHILE e= expression bs= blockstatement )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:79:5: WHILE e= expression bs= blockstatement
			{
			DebugLocation(79, 5);
			Match(input,WHILE,Follow._WHILE_in_whilestatement396); if (state.failed) return result;
			DebugLocation(79, 12);
			PushFollow(Follow._expression_in_whilestatement400);
			e=expression();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(79, 26);
			PushFollow(Follow._blockstatement_in_whilestatement404);
			bs=blockstatement();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(79, 42);
			if (state.backtracking == 0)
			{
				result = new MyWhileStatement(e, bs); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("whilestatement", 7);
			LeaveRule("whilestatement", 7);
			LeaveRule_whilestatement();
		}
		DebugLocation(80, 4);
		} finally { DebugExitRule(GrammarFileName, "whilestatement"); }
		return result;

	}
	// $ANTLR end "whilestatement"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:83:1: statement returns [MyStatementNode result] : (a= assignment |i= ifstatement |r= returnstatement |w= whilestatement |bs= blockstatement ) ;
	[GrammarRule("statement")]
	private MyStatementNode statement()
	{
		EnterRule_statement();
		EnterRule("statement", 8);
		TraceIn("statement", 8);
		MyStatementNode result = default(MyStatementNode);


		MyAssignmentNode a = default(MyAssignmentNode);
		MyIfStatement i = default(MyIfStatement);
		MyReturnStatement r = default(MyReturnStatement);
		MyWhileStatement w = default(MyWhileStatement);
		MyStatementListNode bs = default(MyStatementListNode);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(83, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:84:5: ( (a= assignment |i= ifstatement |r= returnstatement |w= whilestatement |bs= blockstatement ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:85:5: (a= assignment |i= ifstatement |r= returnstatement |w= whilestatement |bs= blockstatement )
			{
			DebugLocation(85, 5);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:85:5: (a= assignment |i= ifstatement |r= returnstatement |w= whilestatement |bs= blockstatement )
			int alt4=5;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case ASSIGN:
				{
				alt4 = 1;
				}
				break;
			case IF:
				{
				alt4 = 2;
				}
				break;
			case RETURN:
				{
				alt4 = 3;
				}
				break;
			case WHILE:
				{
				alt4 = 4;
				}
				break;
			case BLOCKSTMT:
				{
				alt4 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:86:7: a= assignment
				{
				DebugLocation(86, 8);
				PushFollow(Follow._assignment_in_statement446);
				a=assignment();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(86, 22);
				if (state.backtracking == 0)
				{
					result = a;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:87:7: i= ifstatement
				{
				DebugLocation(87, 8);
				PushFollow(Follow._ifstatement_in_statement460);
				i=ifstatement();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(87, 22);
				if (state.backtracking == 0)
				{
					result = i;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:88:7: r= returnstatement
				{
				DebugLocation(88, 8);
				PushFollow(Follow._returnstatement_in_statement473);
				r=returnstatement();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(88, 25);
				if (state.backtracking == 0)
				{
					result = r;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:89:7: w= whilestatement
				{
				DebugLocation(89, 8);
				PushFollow(Follow._whilestatement_in_statement485);
				w=whilestatement();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(89, 24);
				if (state.backtracking == 0)
				{
					result = w;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:90:7: bs= blockstatement
				{
				DebugLocation(90, 9);
				PushFollow(Follow._blockstatement_in_statement497);
				bs=blockstatement();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(90, 25);
				if (state.backtracking == 0)
				{
					result = bs;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 8);
			LeaveRule("statement", 8);
			LeaveRule_statement();
		}
		DebugLocation(92, 4);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return result;

	}
	// $ANTLR end "statement"

	partial void EnterRule_returnstatement();
	partial void LeaveRule_returnstatement();

	// $ANTLR start "returnstatement"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:93:1: returnstatement returns [MyReturnStatement result] : ^( RETURN e= expression ) ;
	[GrammarRule("returnstatement")]
	private MyReturnStatement returnstatement()
	{
		EnterRule_returnstatement();
		EnterRule("returnstatement", 9);
		TraceIn("returnstatement", 9);
		MyReturnStatement result = default(MyReturnStatement);


		MyAbstractNode e = default(MyAbstractNode);

		try { DebugEnterRule(GrammarFileName, "returnstatement");
		DebugLocation(93, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:94:5: ( ^( RETURN e= expression ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:94:7: ^( RETURN e= expression )
			{
			DebugLocation(94, 7);
			DebugLocation(94, 9);
			Match(input,RETURN,Follow._RETURN_in_returnstatement526); if (state.failed) return result;

			Match(input, TokenTypes.Down, null); if (state.failed) return result;
			DebugLocation(94, 17);
			PushFollow(Follow._expression_in_returnstatement530);
			e=expression();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(94, 29);
			if (state.backtracking == 0)
			{
				result = new MyReturnStatement(e);
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return result;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("returnstatement", 9);
			LeaveRule("returnstatement", 9);
			LeaveRule_returnstatement();
		}
		DebugLocation(95, 4);
		} finally { DebugExitRule(GrammarFileName, "returnstatement"); }
		return result;

	}
	// $ANTLR end "returnstatement"

	partial void EnterRule_funcdecl();
	partial void LeaveRule_funcdecl();

	// $ANTLR start "funcdecl"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:98:1: funcdecl returns [MyFunctionDecleration result = new MyFunctionDecleration()] : ^( FUNCDECL funcname= IDENTIFIER (p= IDENTIFIER )* bs= blockstatement ) ;
	[GrammarRule("funcdecl")]
	private MyFunctionDecleration funcdecl()
	{
		EnterRule_funcdecl();
		EnterRule("funcdecl", 10);
		TraceIn("funcdecl", 10);
		MyFunctionDecleration result =  new MyFunctionDecleration();


		CommonTree funcname = default(CommonTree);
		CommonTree p = default(CommonTree);
		MyStatementListNode bs = default(MyStatementListNode);


					result = new MyFunctionDecleration();
				
		try { DebugEnterRule(GrammarFileName, "funcdecl");
		DebugLocation(98, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:106:5: ( ^( FUNCDECL funcname= IDENTIFIER (p= IDENTIFIER )* bs= blockstatement ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:107:5: ^( FUNCDECL funcname= IDENTIFIER (p= IDENTIFIER )* bs= blockstatement )
			{
			DebugLocation(107, 5);
			DebugLocation(107, 7);
			Match(input,FUNCDECL,Follow._FUNCDECL_in_funcdecl585); if (state.failed) return result;

			Match(input, TokenTypes.Down, null); if (state.failed) return result;
			DebugLocation(108, 14);
			funcname=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl596); if (state.failed) return result;
			DebugLocation(109, 6);
			if (state.backtracking == 0)
			{

				    		result.Name = funcname.Text;
				    	
			}
			DebugLocation(112, 5);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:112:5: (p= IDENTIFIER )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==IDENTIFIER))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:112:7: p= IDENTIFIER
					{
					DebugLocation(112, 9);
					p=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl616); if (state.failed) return result;
					DebugLocation(112, 23);
					if (state.backtracking == 0)
					{
						result.Params.Add(p.Text);
					}

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(113, 7);
			PushFollow(Follow._blockstatement_in_funcdecl631);
			bs=blockstatement();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(114, 9);
			if (state.backtracking == 0)
			{

				            result.Statements = bs;
				        
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return result;


			}

			if (state.backtracking == 0)
			{

						
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcdecl", 10);
			LeaveRule("funcdecl", 10);
			LeaveRule_funcdecl();
		}
		DebugLocation(117, 4);
		} finally { DebugExitRule(GrammarFileName, "funcdecl"); }
		return result;

	}
	// $ANTLR end "funcdecl"

	partial void EnterRule_funccall();
	partial void LeaveRule_funccall();

	// $ANTLR start "funccall"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:119:1: funccall returns [MyFunctionCallNode result] : ^( FUNCCALL id= IDENTIFIER vpl= valueparamlist ) ;
	[GrammarRule("funccall")]
	private MyFunctionCallNode funccall()
	{
		EnterRule_funccall();
		EnterRule("funccall", 11);
		TraceIn("funccall", 11);
		MyFunctionCallNode result = default(MyFunctionCallNode);


		CommonTree id = default(CommonTree);
		List<MyAbstractNode> vpl = default(List<MyAbstractNode>);


				result = new MyFunctionCallNode();
			
		try { DebugEnterRule(GrammarFileName, "funccall");
		DebugLocation(119, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:124:5: ( ^( FUNCCALL id= IDENTIFIER vpl= valueparamlist ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:124:8: ^( FUNCCALL id= IDENTIFIER vpl= valueparamlist )
			{
			DebugLocation(124, 8);
			DebugLocation(124, 10);
			Match(input,FUNCCALL,Follow._FUNCCALL_in_funccall672); if (state.failed) return result;

			Match(input, TokenTypes.Down, null); if (state.failed) return result;
			DebugLocation(125, 9);
			id=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funccall684); if (state.failed) return result;
			DebugLocation(126, 6);
			if (state.backtracking == 0)
			{

						result.Name = id.Text;
				   		
			}
			DebugLocation(129, 10);
			PushFollow(Follow._valueparamlist_in_funccall703);
			vpl=valueparamlist();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(130, 3);
			if (state.backtracking == 0)
			{

						    result.Args = vpl;
						
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return result;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funccall", 11);
			LeaveRule("funccall", 11);
			LeaveRule_funccall();
		}
		DebugLocation(134, 4);
		} finally { DebugExitRule(GrammarFileName, "funccall"); }
		return result;

	}
	// $ANTLR end "funccall"

	partial void EnterRule_valueparamlist();
	partial void LeaveRule_valueparamlist();

	// $ANTLR start "valueparamlist"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:137:1: valueparamlist returns [List<MyAbstractNode> result] : e= expression (e= expression )* ;
	[GrammarRule("valueparamlist")]
	private List<MyAbstractNode> valueparamlist()
	{
		EnterRule_valueparamlist();
		EnterRule("valueparamlist", 12);
		TraceIn("valueparamlist", 12);
		List<MyAbstractNode> result = default(List<MyAbstractNode>);


		MyAbstractNode e = default(MyAbstractNode);

		try { DebugEnterRule(GrammarFileName, "valueparamlist");
		DebugLocation(137, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:138:5: (e= expression (e= expression )* )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:138:7: e= expression (e= expression )*
			{
			DebugLocation(138, 9);
			PushFollow(Follow._expression_in_valueparamlist748);
			e=expression();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(138, 22);
			if (state.backtracking == 0)
			{
				 
				                        result = new List<MyAbstractNode>();
				                        result.Add(e);
				                     
			}
			DebugLocation(142, 7);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:142:7: (e= expression )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==AND||LA6_0==DIVIDE||LA6_0==EQUALS||(LA6_0>=FLOAT && LA6_0<=FUNCCALL)||(LA6_0>=GT && LA6_0<=GTEQ)||LA6_0==INT||(LA6_0>=LT && LA6_0<=PLUS)||LA6_0==VAR))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:142:8: e= expression
					{
					DebugLocation(142, 10);
					PushFollow(Follow._expression_in_valueparamlist763);
					e=expression();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(142, 23);
					if (state.backtracking == 0)
					{
						result.Add(e);
					}

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("valueparamlist", 12);
			LeaveRule("valueparamlist", 12);
			LeaveRule_valueparamlist();
		}
		DebugLocation(143, 4);
		} finally { DebugExitRule(GrammarFileName, "valueparamlist"); }
		return result;

	}
	// $ANTLR end "valueparamlist"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:150:1: expression returns [MyAbstractNode result] : ( ^( PLUS left= expression right= expression ) | ^( MINUS left= expression right= expression ) | ^( MULTIPLY left= expression right= expression ) | ^( DIVIDE left= expression right= expression ) | ^( AND left= expression right= expression ) | ^( OR left= expression right= expression ) | ^( EQUALS left= expression right= expression ) | ^( GT left= expression right= expression ) | ^( GTEQ left= expression right= expression ) | ^( LT left= expression right= expression ) | ^( LTEQ left= expression right= expression ) | ^( NEGATE op= expression ) |i= INT |f= FLOAT | ^( VAR id= IDENTIFIER ) |fc= funccall );
	[GrammarRule("expression")]
	private MyAbstractNode expression()
	{
		EnterRule_expression();
		EnterRule("expression", 13);
		TraceIn("expression", 13);
		MyAbstractNode result = default(MyAbstractNode);


		CommonTree i = default(CommonTree);
		CommonTree f = default(CommonTree);
		CommonTree id = default(CommonTree);
		MyAbstractNode left = default(MyAbstractNode);
		MyAbstractNode right = default(MyAbstractNode);
		MyAbstractNode op = default(MyAbstractNode);
		MyFunctionCallNode fc = default(MyFunctionCallNode);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(150, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:151:5: ( ^( PLUS left= expression right= expression ) | ^( MINUS left= expression right= expression ) | ^( MULTIPLY left= expression right= expression ) | ^( DIVIDE left= expression right= expression ) | ^( AND left= expression right= expression ) | ^( OR left= expression right= expression ) | ^( EQUALS left= expression right= expression ) | ^( GT left= expression right= expression ) | ^( GTEQ left= expression right= expression ) | ^( LT left= expression right= expression ) | ^( LTEQ left= expression right= expression ) | ^( NEGATE op= expression ) |i= INT |f= FLOAT | ^( VAR id= IDENTIFIER ) |fc= funccall )
			int alt7=16;
			try { DebugEnterDecision(7, false);
			switch (input.LA(1))
			{
			case PLUS:
				{
				alt7 = 1;
				}
				break;
			case MINUS:
				{
				alt7 = 2;
				}
				break;
			case MULTIPLY:
				{
				alt7 = 3;
				}
				break;
			case DIVIDE:
				{
				alt7 = 4;
				}
				break;
			case AND:
				{
				alt7 = 5;
				}
				break;
			case OR:
				{
				alt7 = 6;
				}
				break;
			case EQUALS:
				{
				alt7 = 7;
				}
				break;
			case GT:
				{
				alt7 = 8;
				}
				break;
			case GTEQ:
				{
				alt7 = 9;
				}
				break;
			case LT:
				{
				alt7 = 10;
				}
				break;
			case LTEQ:
				{
				alt7 = 11;
				}
				break;
			case NEGATE:
				{
				alt7 = 12;
				}
				break;
			case INT:
				{
				alt7 = 13;
				}
				break;
			case FLOAT:
				{
				alt7 = 14;
				}
				break;
			case VAR:
				{
				alt7 = 15;
				}
				break;
			case FUNCCALL:
				{
				alt7 = 16;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:151:7: ^( PLUS left= expression right= expression )
				{
				DebugLocation(151, 7);
				DebugLocation(151, 9);
				Match(input,PLUS,Follow._PLUS_in_expression812); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(151, 18);
				PushFollow(Follow._expression_in_expression816);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(151, 35);
				PushFollow(Follow._expression_in_expression820);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(151, 47);
				if (state.backtracking == 0)
				{
					 result = new MyAddNode(left, right);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:152:7: ^( MINUS left= expression right= expression )
				{
				DebugLocation(152, 7);
				DebugLocation(152, 9);
				Match(input,MINUS,Follow._MINUS_in_expression832); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(152, 20);
				PushFollow(Follow._expression_in_expression837);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(152, 37);
				PushFollow(Follow._expression_in_expression841);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(152, 49);
				if (state.backtracking == 0)
				{
					 result = new MyMinusNode(left, right);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:153:7: ^( MULTIPLY left= expression right= expression )
				{
				DebugLocation(153, 7);
				DebugLocation(153, 9);
				Match(input,MULTIPLY,Follow._MULTIPLY_in_expression853); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(153, 23);
				PushFollow(Follow._expression_in_expression858);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(153, 40);
				PushFollow(Follow._expression_in_expression862);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(153, 51);
				if (state.backtracking == 0)
				{
					 result = new MyMultiplyNode(left, right);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:154:7: ^( DIVIDE left= expression right= expression )
				{
				DebugLocation(154, 7);
				DebugLocation(154, 9);
				Match(input,DIVIDE,Follow._DIVIDE_in_expression873); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(154, 21);
				PushFollow(Follow._expression_in_expression878);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(154, 38);
				PushFollow(Follow._expression_in_expression882);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(154, 50);
				if (state.backtracking == 0)
				{
					 result = new MyDivideNode(left, right);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:155:7: ^( AND left= expression right= expression )
				{
				DebugLocation(155, 7);
				DebugLocation(155, 9);
				Match(input,AND,Follow._AND_in_expression894); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(155, 17);
				PushFollow(Follow._expression_in_expression898);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(155, 34);
				PushFollow(Follow._expression_in_expression902);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(155, 47);
				if (state.backtracking == 0)
				{
					 result = new MyLogicalAndNode(left, right);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:156:7: ^( OR left= expression right= expression )
				{
				DebugLocation(156, 7);
				DebugLocation(156, 9);
				Match(input,OR,Follow._OR_in_expression915); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(156, 16);
				PushFollow(Follow._expression_in_expression919);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(156, 33);
				PushFollow(Follow._expression_in_expression923);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(156, 46);
				if (state.backtracking == 0)
				{
					 result = new MyLogicalOrNode(left, right);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:157:7: ^( EQUALS left= expression right= expression )
				{
				DebugLocation(157, 7);
				DebugLocation(157, 9);
				Match(input,EQUALS,Follow._EQUALS_in_expression936); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(157, 20);
				PushFollow(Follow._expression_in_expression940);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(157, 37);
				PushFollow(Follow._expression_in_expression944);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(157, 49);
				if (state.backtracking == 0)
				{
					 result = new MyIsEqualsNode(left, right);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:158:7: ^( GT left= expression right= expression )
				{
				DebugLocation(158, 7);
				DebugLocation(158, 9);
				Match(input,GT,Follow._GT_in_expression956); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(158, 16);
				PushFollow(Follow._expression_in_expression960);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(158, 33);
				PushFollow(Follow._expression_in_expression964);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(158, 46);
				if (state.backtracking == 0)
				{
					 result = new MyIsGreaterThanNode(left, right);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:159:7: ^( GTEQ left= expression right= expression )
				{
				DebugLocation(159, 7);
				DebugLocation(159, 9);
				Match(input,GTEQ,Follow._GTEQ_in_expression977); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(159, 18);
				PushFollow(Follow._expression_in_expression981);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(159, 35);
				PushFollow(Follow._expression_in_expression985);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(159, 48);
				if (state.backtracking == 0)
				{
					 result = new MyIsGreaterThanOrEqualNode(left, right);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 10:
				DebugEnterAlt(10);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:160:7: ^( LT left= expression right= expression )
				{
				DebugLocation(160, 7);
				DebugLocation(160, 9);
				Match(input,LT,Follow._LT_in_expression998); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(160, 16);
				PushFollow(Follow._expression_in_expression1002);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(160, 33);
				PushFollow(Follow._expression_in_expression1006);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(160, 46);
				if (state.backtracking == 0)
				{
					 result = new MyIsLessThanNode(left, right);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 11:
				DebugEnterAlt(11);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:161:7: ^( LTEQ left= expression right= expression )
				{
				DebugLocation(161, 7);
				DebugLocation(161, 9);
				Match(input,LTEQ,Follow._LTEQ_in_expression1019); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(161, 18);
				PushFollow(Follow._expression_in_expression1023);
				left=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(161, 35);
				PushFollow(Follow._expression_in_expression1027);
				right=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(161, 48);
				if (state.backtracking == 0)
				{
					 result = new MyIsLessThanOrEqualNode(left, right);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 12:
				DebugEnterAlt(12);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:162:7: ^( NEGATE op= expression )
				{
				DebugLocation(162, 7);
				DebugLocation(162, 9);
				Match(input,NEGATE,Follow._NEGATE_in_expression1040); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(162, 18);
				PushFollow(Follow._expression_in_expression1044);
				op=expression();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(162, 35);
				if (state.backtracking == 0)
				{
					 result = new MyNegateNode(op);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 13:
				DebugEnterAlt(13);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:163:7: i= INT
				{
				DebugLocation(163, 8);
				i=(CommonTree)Match(input,INT,Follow._INT_in_expression1062); if (state.failed) return result;
				DebugLocation(163, 24);
				if (state.backtracking == 0)
				{
					 result = new MyValueNode(Int32.Parse(i.Text));
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:164:7: f= FLOAT
				{
				DebugLocation(164, 8);
				f=(CommonTree)Match(input,FLOAT,Follow._FLOAT_in_expression1085); if (state.failed) return result;
				DebugLocation(164, 24);
				if (state.backtracking == 0)
				{
					 result = new MyValueNode(Double.Parse(f.Text));
				}

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:165:7: ^( VAR id= IDENTIFIER )
				{
				DebugLocation(165, 7);
				DebugLocation(165, 9);
				Match(input,VAR,Follow._VAR_in_expression1105); if (state.failed) return result;

				Match(input, TokenTypes.Down, null); if (state.failed) return result;
				DebugLocation(165, 15);
				id=(CommonTree)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_expression1109); if (state.failed) return result;
				DebugLocation(165, 33);
				if (state.backtracking == 0)
				{
					 result = new MyVariableNode(id.Text);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return result;


				}
				break;
			case 16:
				DebugEnterAlt(16);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:166:7: fc= funccall
				{
				DebugLocation(166, 9);
				PushFollow(Follow._funccall_in_expression1128);
				fc=funccall();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(166, 27);
				if (state.backtracking == 0)
				{
					 result = fc;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 13);
			LeaveRule("expression", 13);
			LeaveRule_expression();
		}
		DebugLocation(167, 4);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return result;

	}
	// $ANTLR end "expression"

	partial void EnterRule_synpred3_MyLangTree_fragment();
	partial void LeaveRule_synpred3_MyLangTree_fragment();

	// $ANTLR start synpred3_MyLangTree
	public void synpred3_MyLangTree_fragment()
	{
		MyStatementListNode elsepart = default(MyStatementListNode);

		EnterRule_synpred3_MyLangTree_fragment();
		EnterRule("synpred3_MyLangTree_fragment", 16);
		TraceIn("synpred3_MyLangTree_fragment", 16);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:74:16: (elsepart= blockstatement )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangTree.g:74:16: elsepart= blockstatement
			{
			DebugLocation(74, 16);
			PushFollow(Follow._blockstatement_in_synpred3_MyLangTree366);
			elsepart=blockstatement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_MyLangTree_fragment", 16);
			LeaveRule("synpred3_MyLangTree_fragment", 16);
			LeaveRule_synpred3_MyLangTree_fragment();
		}
	}
	// $ANTLR end synpred3_MyLangTree
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _RUNPROG_in_runprogram88 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENTIFIER_in_runprogram92 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PROGDECL_in_program150 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _identifier_in_program154 = new BitSet(new ulong[]{0x200040UL});
		public static readonly BitSet _funcdecl_in_program168 = new BitSet(new ulong[]{0x200040UL});
		public static readonly BitSet _blockstatement_in_program177 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IDENTIFIER_in_identifier205 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BLOCKSTMT_in_blockstatement251 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_blockstatement264 = new BitSet(new ulong[]{0x4020004000068UL});
		public static readonly BitSet _ASSIGN_in_assignment294 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENTIFIER_in_assignment296 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_assignment300 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IF_in_ifstatement338 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_ifstatement342 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _blockstatement_in_ifstatement346 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _blockstatement_in_ifstatement366 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_whilestatement396 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_whilestatement400 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _blockstatement_in_whilestatement404 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignment_in_statement446 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifstatement_in_statement460 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnstatement_in_statement473 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whilestatement_in_statement485 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _blockstatement_in_statement497 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_returnstatement526 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_returnstatement530 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FUNCDECL_in_funcdecl585 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl596 = new BitSet(new ulong[]{0x2000040UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl616 = new BitSet(new ulong[]{0x2000040UL});
		public static readonly BitSet _blockstatement_in_funcdecl631 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FUNCCALL_in_funccall672 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENTIFIER_in_funccall684 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _valueparamlist_in_funccall703 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _expression_in_valueparamlist748 = new BitSet(new ulong[]{0x2003F899A2012UL});
		public static readonly BitSet _expression_in_valueparamlist763 = new BitSet(new ulong[]{0x2003F899A2012UL});
		public static readonly BitSet _PLUS_in_expression812 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression816 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_expression820 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MINUS_in_expression832 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression837 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_expression841 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MULTIPLY_in_expression853 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression858 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_expression862 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DIVIDE_in_expression873 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression878 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_expression882 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _AND_in_expression894 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression898 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_expression902 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _OR_in_expression915 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression919 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_expression923 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EQUALS_in_expression936 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression940 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_expression944 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GT_in_expression956 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression960 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_expression964 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GTEQ_in_expression977 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression981 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_expression985 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LT_in_expression998 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression1002 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_expression1006 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LTEQ_in_expression1019 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression1023 = new BitSet(new ulong[]{0x2003F899A2010UL});
		public static readonly BitSet _expression_in_expression1027 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NEGATE_in_expression1040 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression1044 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _INT_in_expression1062 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_expression1085 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_expression1105 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENTIFIER_in_expression1109 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _funccall_in_expression1128 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _blockstatement_in_synpred3_MyLangTree366 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  MyLanguageImpl.Grammar 
