//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g 2016-10-24 08:35:35

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  MyLanguageImpl.Grammar 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class MyLangParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ASSIGN", "BLOCKSTMT", "CALL", "COLON", "COMMA", "COMMENT", "DECLARE", "DIGIT", "DIVIDE", "DOT", "ELSE", "ENDP", "EQUALS", "EXPONENT", "FLOAT", "FUNCCALL", "FUNCDECL", "FUNCTION", "GT", "GTEQ", "IDENTIFIER", "IF", "INT", "LCLETTER", "LCURLY", "LPAREN", "LT", "LTEQ", "MINUS", "MULTIPLY", "NEGATE", "OR", "PLUS", "PROGDECL", "PROGRAM", "RCURLY", "RETURN", "RPAREN", "RUN", "RUNPROG", "SEMI", "THEN", "UCLETTER", "USCORE", "VAR", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int ASSIGN=5;
	public const int BLOCKSTMT=6;
	public const int CALL=7;
	public const int COLON=8;
	public const int COMMA=9;
	public const int COMMENT=10;
	public const int DECLARE=11;
	public const int DIGIT=12;
	public const int DIVIDE=13;
	public const int DOT=14;
	public const int ELSE=15;
	public const int ENDP=16;
	public const int EQUALS=17;
	public const int EXPONENT=18;
	public const int FLOAT=19;
	public const int FUNCCALL=20;
	public const int FUNCDECL=21;
	public const int FUNCTION=22;
	public const int GT=23;
	public const int GTEQ=24;
	public const int IDENTIFIER=25;
	public const int IF=26;
	public const int INT=27;
	public const int LCLETTER=28;
	public const int LCURLY=29;
	public const int LPAREN=30;
	public const int LT=31;
	public const int LTEQ=32;
	public const int MINUS=33;
	public const int MULTIPLY=34;
	public const int NEGATE=35;
	public const int OR=36;
	public const int PLUS=37;
	public const int PROGDECL=38;
	public const int PROGRAM=39;
	public const int RCURLY=40;
	public const int RETURN=41;
	public const int RPAREN=42;
	public const int RUN=43;
	public const int RUNPROG=44;
	public const int SEMI=45;
	public const int THEN=46;
	public const int UCLETTER=47;
	public const int USCORE=48;
	public const int VAR=49;
	public const int WHILE=50;
	public const int WS=51;

	public MyLangParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public MyLangParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return MyLangParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();

	// $ANTLR start "identifier"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:25:1: identifier : IDENTIFIER ^;
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<CommonTree, IToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 1);
		TraceIn("identifier", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENTIFIER1 = default(IToken);

		CommonTree IDENTIFIER1_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(25, 14);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:26:2: ( IDENTIFIER ^)
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:26:4: IDENTIFIER ^
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(26, 14);
			IDENTIFIER1=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_identifier137); if (state.failed) return retval;
			if (state.backtracking == 0) {
			IDENTIFIER1_tree = (CommonTree)adaptor.Create(IDENTIFIER1);
			root_0 = (CommonTree)adaptor.BecomeRoot(IDENTIFIER1_tree, root_0);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier", 1);
			LeaveRule("identifier", 1);
			LeaveRule_identifier();
		}
		DebugLocation(26, 14);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_runprogram();
	partial void LeaveRule_runprogram();

	// $ANTLR start "runprogram"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:28:8: public runprogram : ( WS )? RUN WS PROGRAM WS IDENTIFIER ( WS )? ( ENDP | EOF ) -> ^( RUNPROG IDENTIFIER ) ;
	[GrammarRule("runprogram")]
	public AstParserRuleReturnScope<CommonTree, IToken> runprogram()
	{
		EnterRule_runprogram();
		EnterRule("runprogram", 2);
		TraceIn("runprogram", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WS2 = default(IToken);
		IToken RUN3 = default(IToken);
		IToken WS4 = default(IToken);
		IToken PROGRAM5 = default(IToken);
		IToken WS6 = default(IToken);
		IToken IDENTIFIER7 = default(IToken);
		IToken WS8 = default(IToken);
		IToken ENDP9 = default(IToken);
		IToken EOF10 = default(IToken);

		CommonTree WS2_tree = default(CommonTree);
		CommonTree RUN3_tree = default(CommonTree);
		CommonTree WS4_tree = default(CommonTree);
		CommonTree PROGRAM5_tree = default(CommonTree);
		CommonTree WS6_tree = default(CommonTree);
		CommonTree IDENTIFIER7_tree = default(CommonTree);
		CommonTree WS8_tree = default(CommonTree);
		CommonTree ENDP9_tree = default(CommonTree);
		CommonTree EOF10_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ENDP=new RewriteRuleITokenStream(adaptor,"token ENDP");
		RewriteRuleITokenStream stream_RUN=new RewriteRuleITokenStream(adaptor,"token RUN");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleITokenStream stream_PROGRAM=new RewriteRuleITokenStream(adaptor,"token PROGRAM");
		try { DebugEnterRule(GrammarFileName, "runprogram");
		DebugLocation(28, 80);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:29:5: ( ( WS )? RUN WS PROGRAM WS IDENTIFIER ( WS )? ( ENDP | EOF ) -> ^( RUNPROG IDENTIFIER ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:29:7: ( WS )? RUN WS PROGRAM WS IDENTIFIER ( WS )? ( ENDP | EOF )
			{
			DebugLocation(29, 7);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:29:7: ( WS )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==WS))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:29:7: WS
				{
				DebugLocation(29, 7);
				WS2=(IToken)Match(input,WS,Follow._WS_in_runprogram153); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS2);


				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(29, 11);
			RUN3=(IToken)Match(input,RUN,Follow._RUN_in_runprogram156); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RUN.Add(RUN3);

			DebugLocation(29, 15);
			WS4=(IToken)Match(input,WS,Follow._WS_in_runprogram158); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS4);

			DebugLocation(29, 18);
			PROGRAM5=(IToken)Match(input,PROGRAM,Follow._PROGRAM_in_runprogram160); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PROGRAM.Add(PROGRAM5);

			DebugLocation(29, 26);
			WS6=(IToken)Match(input,WS,Follow._WS_in_runprogram162); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS6);

			DebugLocation(29, 29);
			IDENTIFIER7=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_runprogram164); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER7);

			DebugLocation(29, 40);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:29:40: ( WS )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==WS))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:29:40: WS
				{
				DebugLocation(29, 40);
				WS8=(IToken)Match(input,WS,Follow._WS_in_runprogram166); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS8);


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(29, 44);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:29:44: ( ENDP | EOF )
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==ENDP))
			{
				alt3 = 1;
			}
			else if ((LA3_0==EOF))
			{
				alt3 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:29:45: ENDP
				{
				DebugLocation(29, 45);
				ENDP9=(IToken)Match(input,ENDP,Follow._ENDP_in_runprogram170); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ENDP.Add(ENDP9);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:29:52: EOF
				{
				DebugLocation(29, 52);
				EOF10=(IToken)Match(input,EOF,Follow._EOF_in_runprogram174); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_EOF.Add(EOF10);


				}
				break;

			}
			} finally { DebugExitSubRule(3); }



			{
			// AST REWRITE
			// elements: IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 29:57: -> ^( RUNPROG IDENTIFIER )
			{
				DebugLocation(29, 60);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:29:60: ^( RUNPROG IDENTIFIER )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(29, 62);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(RUNPROG, "RUNPROG"), root_1);

				DebugLocation(29, 70);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("runprogram", 2);
			LeaveRule("runprogram", 2);
			LeaveRule_runprogram();
		}
		DebugLocation(29, 80);
		} finally { DebugExitRule(GrammarFileName, "runprogram"); }
		return retval;

	}
	// $ANTLR end "runprogram"

	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:31:8: public program : ( WS )? DECLARE WS PROGRAM ( WS )? COLON WS identifier ( WS )? LCURLY ( WS )? ( funcdecl )* ( WS )? blockstatement ( WS )? RCURLY ( WS )? ( ENDP | EOF ) -> ^( PROGDECL identifier ( funcdecl )* blockstatement ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 3);
		TraceIn("program", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WS11 = default(IToken);
		IToken DECLARE12 = default(IToken);
		IToken WS13 = default(IToken);
		IToken PROGRAM14 = default(IToken);
		IToken WS15 = default(IToken);
		IToken COLON16 = default(IToken);
		IToken WS17 = default(IToken);
		IToken WS19 = default(IToken);
		IToken LCURLY20 = default(IToken);
		IToken WS21 = default(IToken);
		IToken WS23 = default(IToken);
		IToken WS25 = default(IToken);
		IToken RCURLY26 = default(IToken);
		IToken WS27 = default(IToken);
		IToken ENDP28 = default(IToken);
		IToken EOF29 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier18 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> funcdecl22 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement24 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WS11_tree = default(CommonTree);
		CommonTree DECLARE12_tree = default(CommonTree);
		CommonTree WS13_tree = default(CommonTree);
		CommonTree PROGRAM14_tree = default(CommonTree);
		CommonTree WS15_tree = default(CommonTree);
		CommonTree COLON16_tree = default(CommonTree);
		CommonTree WS17_tree = default(CommonTree);
		CommonTree WS19_tree = default(CommonTree);
		CommonTree LCURLY20_tree = default(CommonTree);
		CommonTree WS21_tree = default(CommonTree);
		CommonTree WS23_tree = default(CommonTree);
		CommonTree WS25_tree = default(CommonTree);
		CommonTree RCURLY26_tree = default(CommonTree);
		CommonTree WS27_tree = default(CommonTree);
		CommonTree ENDP28_tree = default(CommonTree);
		CommonTree EOF29_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DECLARE=new RewriteRuleITokenStream(adaptor,"token DECLARE");
		RewriteRuleITokenStream stream_ENDP=new RewriteRuleITokenStream(adaptor,"token ENDP");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleITokenStream stream_PROGRAM=new RewriteRuleITokenStream(adaptor,"token PROGRAM");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_funcdecl=new RewriteRuleSubtreeStream(adaptor,"rule funcdecl");
		RewriteRuleSubtreeStream stream_blockstatement=new RewriteRuleSubtreeStream(adaptor,"rule blockstatement");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(31, 176);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:32:5: ( ( WS )? DECLARE WS PROGRAM ( WS )? COLON WS identifier ( WS )? LCURLY ( WS )? ( funcdecl )* ( WS )? blockstatement ( WS )? RCURLY ( WS )? ( ENDP | EOF ) -> ^( PROGDECL identifier ( funcdecl )* blockstatement ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:7: ( WS )? DECLARE WS PROGRAM ( WS )? COLON WS identifier ( WS )? LCURLY ( WS )? ( funcdecl )* ( WS )? blockstatement ( WS )? RCURLY ( WS )? ( ENDP | EOF )
			{
			DebugLocation(33, 7);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:7: ( WS )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==WS))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:7: WS
				{
				DebugLocation(33, 7);
				WS11=(IToken)Match(input,WS,Follow._WS_in_program204); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS11);


				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(33, 11);
			DECLARE12=(IToken)Match(input,DECLARE,Follow._DECLARE_in_program207); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DECLARE.Add(DECLARE12);

			DebugLocation(33, 19);
			WS13=(IToken)Match(input,WS,Follow._WS_in_program209); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS13);

			DebugLocation(33, 22);
			PROGRAM14=(IToken)Match(input,PROGRAM,Follow._PROGRAM_in_program211); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PROGRAM.Add(PROGRAM14);

			DebugLocation(33, 30);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:30: ( WS )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==WS))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:30: WS
				{
				DebugLocation(33, 30);
				WS15=(IToken)Match(input,WS,Follow._WS_in_program213); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS15);


				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(33, 34);
			COLON16=(IToken)Match(input,COLON,Follow._COLON_in_program216); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON16);

			DebugLocation(33, 40);
			WS17=(IToken)Match(input,WS,Follow._WS_in_program218); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS17);

			DebugLocation(33, 43);
			PushFollow(Follow._identifier_in_program220);
			identifier18=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier18.Tree);
			DebugLocation(33, 54);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:54: ( WS )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==WS))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:54: WS
				{
				DebugLocation(33, 54);
				WS19=(IToken)Match(input,WS,Follow._WS_in_program222); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS19);


				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(33, 58);
			LCURLY20=(IToken)Match(input,LCURLY,Follow._LCURLY_in_program225); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY20);

			DebugLocation(33, 65);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:65: ( WS )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==WS))
			{
				int LA7_1 = input.LA(2);

				if ((EvaluatePredicate(synpred7_MyLangParser_fragment)))
				{
					alt7 = 1;
				}
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:65: WS
				{
				DebugLocation(33, 65);
				WS21=(IToken)Match(input,WS,Follow._WS_in_program227); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS21);


				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(33, 69);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:69: ( funcdecl )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==WS))
				{
					int LA8_1 = input.LA(2);

					if ((LA8_1==DECLARE))
					{
						alt8 = 1;
					}


				}
				else if ((LA8_0==DECLARE))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:69: funcdecl
					{
					DebugLocation(33, 69);
					PushFollow(Follow._funcdecl_in_program230);
					funcdecl22=funcdecl();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_funcdecl.Add(funcdecl22.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(33, 79);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:79: ( WS )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==WS))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:79: WS
				{
				DebugLocation(33, 79);
				WS23=(IToken)Match(input,WS,Follow._WS_in_program233); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS23);


				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(33, 83);
			PushFollow(Follow._blockstatement_in_program236);
			blockstatement24=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_blockstatement.Add(blockstatement24.Tree);
			DebugLocation(33, 98);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:98: ( WS )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==WS))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:98: WS
				{
				DebugLocation(33, 98);
				WS25=(IToken)Match(input,WS,Follow._WS_in_program238); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS25);


				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(33, 102);
			RCURLY26=(IToken)Match(input,RCURLY,Follow._RCURLY_in_program241); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY26);

			DebugLocation(33, 109);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:109: ( WS )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==WS))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:109: WS
				{
				DebugLocation(33, 109);
				WS27=(IToken)Match(input,WS,Follow._WS_in_program243); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS27);


				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(33, 113);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:113: ( ENDP | EOF )
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if ((LA12_0==ENDP))
			{
				alt12 = 1;
			}
			else if ((LA12_0==EOF))
			{
				alt12 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:114: ENDP
				{
				DebugLocation(33, 114);
				ENDP28=(IToken)Match(input,ENDP,Follow._ENDP_in_program247); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ENDP.Add(ENDP28);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:122: EOF
				{
				DebugLocation(33, 122);
				EOF29=(IToken)Match(input,EOF,Follow._EOF_in_program252); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_EOF.Add(EOF29);


				}
				break;

			}
			} finally { DebugExitSubRule(12); }



			{
			// AST REWRITE
			// elements: funcdecl, blockstatement, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 33:127: -> ^( PROGDECL identifier ( funcdecl )* blockstatement )
			{
				DebugLocation(33, 130);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:130: ^( PROGDECL identifier ( funcdecl )* blockstatement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(33, 132);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROGDECL, "PROGDECL"), root_1);

				DebugLocation(33, 141);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(33, 152);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:152: ( funcdecl )*
				while ( stream_funcdecl.HasNext )
				{
					DebugLocation(33, 152);
					adaptor.AddChild(root_1, stream_funcdecl.NextTree());

				}
				stream_funcdecl.Reset();
				DebugLocation(33, 162);
				adaptor.AddChild(root_1, stream_blockstatement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 3);
			LeaveRule("program", 3);
			LeaveRule_program();
		}
		DebugLocation(33, 176);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_blockstatement();
	partial void LeaveRule_blockstatement();

	// $ANTLR start "blockstatement"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:35:1: blockstatement : LCURLY ( statement )* RCURLY -> ^( BLOCKSTMT ( statement )* ) ;
	[GrammarRule("blockstatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> blockstatement()
	{
		EnterRule_blockstatement();
		EnterRule("blockstatement", 4);
		TraceIn("blockstatement", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LCURLY30 = default(IToken);
		IToken RCURLY32 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement31 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LCURLY30_tree = default(CommonTree);
		CommonTree RCURLY32_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "blockstatement");
		DebugLocation(35, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:36:5: ( LCURLY ( statement )* RCURLY -> ^( BLOCKSTMT ( statement )* ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:36:7: LCURLY ( statement )* RCURLY
			{
			DebugLocation(36, 7);
			LCURLY30=(IToken)Match(input,LCURLY,Follow._LCURLY_in_blockstatement279); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY30);

			DebugLocation(36, 14);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:36:14: ( statement )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if (((LA13_0>=IDENTIFIER && LA13_0<=IF)||LA13_0==LCURLY||LA13_0==RETURN||LA13_0==WHILE))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:36:14: statement
					{
					DebugLocation(36, 14);
					PushFollow(Follow._statement_in_blockstatement281);
					statement31=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement31.Tree);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(36, 25);
			RCURLY32=(IToken)Match(input,RCURLY,Follow._RCURLY_in_blockstatement284); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY32);



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 36:32: -> ^( BLOCKSTMT ( statement )* )
			{
				DebugLocation(36, 35);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:36:35: ^( BLOCKSTMT ( statement )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(36, 37);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BLOCKSTMT, "BLOCKSTMT"), root_1);

				DebugLocation(36, 47);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:36:47: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(36, 47);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("blockstatement", 4);
			LeaveRule("blockstatement", 4);
			LeaveRule_blockstatement();
		}
		DebugLocation(37, 4);
		} finally { DebugExitRule(GrammarFileName, "blockstatement"); }
		return retval;

	}
	// $ANTLR end "blockstatement"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();

	// $ANTLR start "assignment"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:39:1: assignment : IDENTIFIER ASSIGN expression -> ^( ASSIGN IDENTIFIER expression ) ;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 5);
		TraceIn("assignment", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENTIFIER33 = default(IToken);
		IToken ASSIGN34 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression35 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENTIFIER33_tree = default(CommonTree);
		CommonTree ASSIGN34_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(39, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:40:5: ( IDENTIFIER ASSIGN expression -> ^( ASSIGN IDENTIFIER expression ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:41:5: IDENTIFIER ASSIGN expression
			{
			DebugLocation(41, 5);
			IDENTIFIER33=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_assignment315); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER33);

			DebugLocation(41, 16);
			ASSIGN34=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_assignment317); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN34);

			DebugLocation(41, 23);
			PushFollow(Follow._expression_in_assignment319);
			expression35=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression35.Tree);


			{
			// AST REWRITE
			// elements: IDENTIFIER, expression, ASSIGN
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 41:34: -> ^( ASSIGN IDENTIFIER expression )
			{
				DebugLocation(41, 37);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:41:37: ^( ASSIGN IDENTIFIER expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(41, 39);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

				DebugLocation(41, 46);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(41, 57);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 5);
			LeaveRule("assignment", 5);
			LeaveRule_assignment();
		}
		DebugLocation(42, 4);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_ifstatement();
	partial void LeaveRule_ifstatement();

	// $ANTLR start "ifstatement"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:44:1: ifstatement : IF LPAREN ! expression RPAREN ! THEN ! blockstatement ( ELSE ! blockstatement )? ;
	[GrammarRule("ifstatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> ifstatement()
	{
		EnterRule_ifstatement();
		EnterRule("ifstatement", 6);
		TraceIn("ifstatement", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IF36 = default(IToken);
		IToken LPAREN37 = default(IToken);
		IToken RPAREN39 = default(IToken);
		IToken THEN40 = default(IToken);
		IToken ELSE42 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression38 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement41 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement43 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IF36_tree = default(CommonTree);
		CommonTree LPAREN37_tree = default(CommonTree);
		CommonTree RPAREN39_tree = default(CommonTree);
		CommonTree THEN40_tree = default(CommonTree);
		CommonTree ELSE42_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "ifstatement");
		DebugLocation(44, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:45:5: ( IF LPAREN ! expression RPAREN ! THEN ! blockstatement ( ELSE ! blockstatement )? )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:46:5: IF LPAREN ! expression RPAREN ! THEN ! blockstatement ( ELSE ! blockstatement )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(46, 5);
			IF36=(IToken)Match(input,IF,Follow._IF_in_ifstatement353); if (state.failed) return retval;
			if (state.backtracking == 0) {
			IF36_tree = (CommonTree)adaptor.Create(IF36);
			adaptor.AddChild(root_0, IF36_tree);
			}
			DebugLocation(46, 14);
			LPAREN37=(IToken)Match(input,LPAREN,Follow._LPAREN_in_ifstatement355); if (state.failed) return retval;
			DebugLocation(46, 16);
			PushFollow(Follow._expression_in_ifstatement358);
			expression38=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression38.Tree);
			DebugLocation(46, 33);
			RPAREN39=(IToken)Match(input,RPAREN,Follow._RPAREN_in_ifstatement360); if (state.failed) return retval;
			DebugLocation(46, 39);
			THEN40=(IToken)Match(input,THEN,Follow._THEN_in_ifstatement363); if (state.failed) return retval;
			DebugLocation(47, 9);
			PushFollow(Follow._blockstatement_in_ifstatement375);
			blockstatement41=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement41.Tree);
			DebugLocation(48, 5);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:48:5: ( ELSE ! blockstatement )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_0 = input.LA(1);

			if ((LA14_0==ELSE))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:49:9: ELSE ! blockstatement
				{
				DebugLocation(49, 13);
				ELSE42=(IToken)Match(input,ELSE,Follow._ELSE_in_ifstatement392); if (state.failed) return retval;
				DebugLocation(50, 9);
				PushFollow(Follow._blockstatement_in_ifstatement404);
				blockstatement43=blockstatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement43.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifstatement", 6);
			LeaveRule("ifstatement", 6);
			LeaveRule_ifstatement();
		}
		DebugLocation(52, 4);
		} finally { DebugExitRule(GrammarFileName, "ifstatement"); }
		return retval;

	}
	// $ANTLR end "ifstatement"

	partial void EnterRule_whilestatement();
	partial void LeaveRule_whilestatement();

	// $ANTLR start "whilestatement"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:54:1: whilestatement : WHILE LPAREN ! expression RPAREN ! blockstatement ;
	[GrammarRule("whilestatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> whilestatement()
	{
		EnterRule_whilestatement();
		EnterRule("whilestatement", 7);
		TraceIn("whilestatement", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WHILE44 = default(IToken);
		IToken LPAREN45 = default(IToken);
		IToken RPAREN47 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression46 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement48 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WHILE44_tree = default(CommonTree);
		CommonTree LPAREN45_tree = default(CommonTree);
		CommonTree RPAREN47_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "whilestatement");
		DebugLocation(54, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:55:5: ( WHILE LPAREN ! expression RPAREN ! blockstatement )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:56:5: WHILE LPAREN ! expression RPAREN ! blockstatement
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(56, 5);
			WHILE44=(IToken)Match(input,WHILE,Follow._WHILE_in_whilestatement434); if (state.failed) return retval;
			if (state.backtracking == 0) {
			WHILE44_tree = (CommonTree)adaptor.Create(WHILE44);
			adaptor.AddChild(root_0, WHILE44_tree);
			}
			DebugLocation(56, 17);
			LPAREN45=(IToken)Match(input,LPAREN,Follow._LPAREN_in_whilestatement436); if (state.failed) return retval;
			DebugLocation(56, 19);
			PushFollow(Follow._expression_in_whilestatement439);
			expression46=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression46.Tree);
			DebugLocation(56, 36);
			RPAREN47=(IToken)Match(input,RPAREN,Follow._RPAREN_in_whilestatement441); if (state.failed) return retval;
			DebugLocation(56, 38);
			PushFollow(Follow._blockstatement_in_whilestatement444);
			blockstatement48=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement48.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whilestatement", 7);
			LeaveRule("whilestatement", 7);
			LeaveRule_whilestatement();
		}
		DebugLocation(57, 4);
		} finally { DebugExitRule(GrammarFileName, "whilestatement"); }
		return retval;

	}
	// $ANTLR end "whilestatement"

	partial void EnterRule_returnstatement();
	partial void LeaveRule_returnstatement();

	// $ANTLR start "returnstatement"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:59:1: returnstatement : RETURN ^ expression ;
	[GrammarRule("returnstatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> returnstatement()
	{
		EnterRule_returnstatement();
		EnterRule("returnstatement", 8);
		TraceIn("returnstatement", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken RETURN49 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression50 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree RETURN49_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "returnstatement");
		DebugLocation(59, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:60:5: ( RETURN ^ expression )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:60:7: RETURN ^ expression
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(60, 13);
			RETURN49=(IToken)Match(input,RETURN,Follow._RETURN_in_returnstatement461); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RETURN49_tree = (CommonTree)adaptor.Create(RETURN49);
			root_0 = (CommonTree)adaptor.BecomeRoot(RETURN49_tree, root_0);
			}
			DebugLocation(60, 15);
			PushFollow(Follow._expression_in_returnstatement464);
			expression50=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression50.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("returnstatement", 8);
			LeaveRule("returnstatement", 8);
			LeaveRule_returnstatement();
		}
		DebugLocation(61, 4);
		} finally { DebugExitRule(GrammarFileName, "returnstatement"); }
		return retval;

	}
	// $ANTLR end "returnstatement"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:63:1: statement : ( assignment | ifstatement | returnstatement | whilestatement | blockstatement ) SEMI !;
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 9);
		TraceIn("statement", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken SEMI56 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignment51 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifstatement52 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> returnstatement53 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> whilestatement54 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement55 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI56_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(63, 9);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:64:5: ( ( assignment | ifstatement | returnstatement | whilestatement | blockstatement ) SEMI !)
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:65:5: ( assignment | ifstatement | returnstatement | whilestatement | blockstatement ) SEMI !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(65, 5);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:65:5: ( assignment | ifstatement | returnstatement | whilestatement | blockstatement )
			int alt15=5;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			switch (input.LA(1))
			{
			case IDENTIFIER:
				{
				alt15 = 1;
				}
				break;
			case IF:
				{
				alt15 = 2;
				}
				break;
			case RETURN:
				{
				alt15 = 3;
				}
				break;
			case WHILE:
				{
				alt15 = 4;
				}
				break;
			case LCURLY:
				{
				alt15 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:66:7: assignment
				{
				DebugLocation(66, 7);
				PushFollow(Follow._assignment_in_statement497);
				assignment51=assignment();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignment51.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:67:7: ifstatement
				{
				DebugLocation(67, 7);
				PushFollow(Follow._ifstatement_in_statement506);
				ifstatement52=ifstatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifstatement52.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:68:7: returnstatement
				{
				DebugLocation(68, 7);
				PushFollow(Follow._returnstatement_in_statement514);
				returnstatement53=returnstatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, returnstatement53.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:69:7: whilestatement
				{
				DebugLocation(69, 7);
				PushFollow(Follow._whilestatement_in_statement522);
				whilestatement54=whilestatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, whilestatement54.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:70:7: blockstatement
				{
				DebugLocation(70, 7);
				PushFollow(Follow._blockstatement_in_statement530);
				blockstatement55=blockstatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, blockstatement55.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(72, 9);
			SEMI56=(IToken)Match(input,SEMI,Follow._SEMI_in_statement550); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 9);
			LeaveRule("statement", 9);
			LeaveRule_statement();
		}
		DebugLocation(72, 9);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_funcdecl();
	partial void LeaveRule_funcdecl();

	// $ANTLR start "funcdecl"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:74:1: funcdecl : ( WS )? DECLARE WS FUNCTION WS COLON WS IDENTIFIER WS LPAREN ( IDENTIFIER ( COMMA IDENTIFIER )* )? RPAREN blockstatement -> ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement ) ;
	[GrammarRule("funcdecl")]
	private AstParserRuleReturnScope<CommonTree, IToken> funcdecl()
	{
		EnterRule_funcdecl();
		EnterRule("funcdecl", 10);
		TraceIn("funcdecl", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WS57 = default(IToken);
		IToken DECLARE58 = default(IToken);
		IToken WS59 = default(IToken);
		IToken FUNCTION60 = default(IToken);
		IToken WS61 = default(IToken);
		IToken COLON62 = default(IToken);
		IToken WS63 = default(IToken);
		IToken IDENTIFIER64 = default(IToken);
		IToken WS65 = default(IToken);
		IToken LPAREN66 = default(IToken);
		IToken IDENTIFIER67 = default(IToken);
		IToken COMMA68 = default(IToken);
		IToken IDENTIFIER69 = default(IToken);
		IToken RPAREN70 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> blockstatement71 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WS57_tree = default(CommonTree);
		CommonTree DECLARE58_tree = default(CommonTree);
		CommonTree WS59_tree = default(CommonTree);
		CommonTree FUNCTION60_tree = default(CommonTree);
		CommonTree WS61_tree = default(CommonTree);
		CommonTree COLON62_tree = default(CommonTree);
		CommonTree WS63_tree = default(CommonTree);
		CommonTree IDENTIFIER64_tree = default(CommonTree);
		CommonTree WS65_tree = default(CommonTree);
		CommonTree LPAREN66_tree = default(CommonTree);
		CommonTree IDENTIFIER67_tree = default(CommonTree);
		CommonTree COMMA68_tree = default(CommonTree);
		CommonTree IDENTIFIER69_tree = default(CommonTree);
		CommonTree RPAREN70_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_DECLARE=new RewriteRuleITokenStream(adaptor,"token DECLARE");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_blockstatement=new RewriteRuleSubtreeStream(adaptor,"rule blockstatement");
		try { DebugEnterRule(GrammarFileName, "funcdecl");
		DebugLocation(74, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:75:5: ( ( WS )? DECLARE WS FUNCTION WS COLON WS IDENTIFIER WS LPAREN ( IDENTIFIER ( COMMA IDENTIFIER )* )? RPAREN blockstatement -> ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:76:5: ( WS )? DECLARE WS FUNCTION WS COLON WS IDENTIFIER WS LPAREN ( IDENTIFIER ( COMMA IDENTIFIER )* )? RPAREN blockstatement
			{
			DebugLocation(76, 5);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:76:5: ( WS )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if ((LA16_0==WS))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:76:5: WS
				{
				DebugLocation(76, 5);
				WS57=(IToken)Match(input,WS,Follow._WS_in_funcdecl569); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS57);


				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(76, 9);
			DECLARE58=(IToken)Match(input,DECLARE,Follow._DECLARE_in_funcdecl572); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DECLARE.Add(DECLARE58);

			DebugLocation(76, 17);
			WS59=(IToken)Match(input,WS,Follow._WS_in_funcdecl574); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS59);

			DebugLocation(76, 20);
			FUNCTION60=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_funcdecl576); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION60);

			DebugLocation(76, 29);
			WS61=(IToken)Match(input,WS,Follow._WS_in_funcdecl578); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS61);

			DebugLocation(76, 32);
			COLON62=(IToken)Match(input,COLON,Follow._COLON_in_funcdecl580); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON62);

			DebugLocation(76, 38);
			WS63=(IToken)Match(input,WS,Follow._WS_in_funcdecl582); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS63);

			DebugLocation(76, 41);
			IDENTIFIER64=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl584); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER64);

			DebugLocation(76, 52);
			WS65=(IToken)Match(input,WS,Follow._WS_in_funcdecl586); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS65);

			DebugLocation(76, 55);
			LPAREN66=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funcdecl588); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN66);

			DebugLocation(76, 62);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:76:62: ( IDENTIFIER ( COMMA IDENTIFIER )* )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if ((LA18_0==IDENTIFIER))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:76:63: IDENTIFIER ( COMMA IDENTIFIER )*
				{
				DebugLocation(76, 63);
				IDENTIFIER67=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl591); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER67);

				DebugLocation(76, 74);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:76:74: ( COMMA IDENTIFIER )*
				try { DebugEnterSubRule(17);
				while (true)
				{
					int alt17=2;
					try { DebugEnterDecision(17, false);
					int LA17_0 = input.LA(1);

					if ((LA17_0==COMMA))
					{
						alt17 = 1;
					}


					} finally { DebugExitDecision(17); }
					switch ( alt17 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:76:75: COMMA IDENTIFIER
						{
						DebugLocation(76, 75);
						COMMA68=(IToken)Match(input,COMMA,Follow._COMMA_in_funcdecl594); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA68);

						DebugLocation(76, 81);
						IDENTIFIER69=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funcdecl596); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER69);


						}
						break;

					default:
						goto loop17;
					}
				}

				loop17:
					;

				} finally { DebugExitSubRule(17); }


				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(76, 96);
			RPAREN70=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funcdecl602); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN70);

			DebugLocation(76, 103);
			PushFollow(Follow._blockstatement_in_funcdecl604);
			blockstatement71=blockstatement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_blockstatement.Add(blockstatement71.Tree);


			{
			// AST REWRITE
			// elements: blockstatement, IDENTIFIER, IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 76:118: -> ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement )
			{
				DebugLocation(76, 121);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:76:121: ^( FUNCDECL IDENTIFIER ( IDENTIFIER )* blockstatement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(76, 123);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNCDECL, "FUNCDECL"), root_1);

				DebugLocation(76, 132);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(76, 143);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:76:143: ( IDENTIFIER )*
				while ( stream_IDENTIFIER.HasNext )
				{
					DebugLocation(76, 143);
					adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());

				}
				stream_IDENTIFIER.Reset();
				DebugLocation(76, 155);
				adaptor.AddChild(root_1, stream_blockstatement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcdecl", 10);
			LeaveRule("funcdecl", 10);
			LeaveRule_funcdecl();
		}
		DebugLocation(77, 4);
		} finally { DebugExitRule(GrammarFileName, "funcdecl"); }
		return retval;

	}
	// $ANTLR end "funcdecl"

	partial void EnterRule_funccall();
	partial void LeaveRule_funccall();

	// $ANTLR start "funccall"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:79:1: funccall : CALL IDENTIFIER LPAREN ( expression ( COMMA expression )* )? RPAREN -> ^( FUNCCALL IDENTIFIER ( expression )* ) ;
	[GrammarRule("funccall")]
	private AstParserRuleReturnScope<CommonTree, IToken> funccall()
	{
		EnterRule_funccall();
		EnterRule("funccall", 11);
		TraceIn("funccall", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken CALL72 = default(IToken);
		IToken IDENTIFIER73 = default(IToken);
		IToken LPAREN74 = default(IToken);
		IToken COMMA76 = default(IToken);
		IToken RPAREN78 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression75 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression77 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CALL72_tree = default(CommonTree);
		CommonTree IDENTIFIER73_tree = default(CommonTree);
		CommonTree LPAREN74_tree = default(CommonTree);
		CommonTree COMMA76_tree = default(CommonTree);
		CommonTree RPAREN78_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_CALL=new RewriteRuleITokenStream(adaptor,"token CALL");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "funccall");
		DebugLocation(79, 101);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:80:5: ( CALL IDENTIFIER LPAREN ( expression ( COMMA expression )* )? RPAREN -> ^( FUNCCALL IDENTIFIER ( expression )* ) )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:81:1: CALL IDENTIFIER LPAREN ( expression ( COMMA expression )* )? RPAREN
			{
			DebugLocation(81, 1);
			CALL72=(IToken)Match(input,CALL,Follow._CALL_in_funccall636); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CALL.Add(CALL72);

			DebugLocation(81, 6);
			IDENTIFIER73=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_funccall638); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER73);

			DebugLocation(81, 17);
			LPAREN74=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funccall640); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN74);

			DebugLocation(81, 24);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:81:24: ( expression ( COMMA expression )* )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0==CALL||LA20_0==FLOAT||LA20_0==IDENTIFIER||LA20_0==INT||LA20_0==LPAREN||LA20_0==MINUS||LA20_0==PLUS))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:81:25: expression ( COMMA expression )*
				{
				DebugLocation(81, 25);
				PushFollow(Follow._expression_in_funccall643);
				expression75=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression75.Tree);
				DebugLocation(81, 36);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:81:36: ( COMMA expression )*
				try { DebugEnterSubRule(19);
				while (true)
				{
					int alt19=2;
					try { DebugEnterDecision(19, false);
					int LA19_0 = input.LA(1);

					if ((LA19_0==COMMA))
					{
						alt19 = 1;
					}


					} finally { DebugExitDecision(19); }
					switch ( alt19 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:81:37: COMMA expression
						{
						DebugLocation(81, 37);
						COMMA76=(IToken)Match(input,COMMA,Follow._COMMA_in_funccall646); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA76);

						DebugLocation(81, 43);
						PushFollow(Follow._expression_in_funccall648);
						expression77=expression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expression.Add(expression77.Tree);

						}
						break;

					default:
						goto loop19;
					}
				}

				loop19:
					;

				} finally { DebugExitSubRule(19); }


				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(81, 58);
			RPAREN78=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funccall654); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN78);



			{
			// AST REWRITE
			// elements: expression, IDENTIFIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 81:65: -> ^( FUNCCALL IDENTIFIER ( expression )* )
			{
				DebugLocation(81, 68);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:81:68: ^( FUNCCALL IDENTIFIER ( expression )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(81, 70);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNCCALL, "FUNCCALL"), root_1);

				DebugLocation(81, 79);
				adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());
				DebugLocation(81, 90);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:81:90: ( expression )*
				while ( stream_expression.HasNext )
				{
					DebugLocation(81, 90);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funccall", 11);
			LeaveRule("funccall", 11);
			LeaveRule_funccall();
		}
		DebugLocation(81, 101);
		} finally { DebugExitRule(GrammarFileName, "funccall"); }
		return retval;

	}
	// $ANTLR end "funccall"

	partial void EnterRule_primary();
	partial void LeaveRule_primary();

	// $ANTLR start "primary"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:85:1: primary : ( INT | FLOAT | IDENTIFIER -> ^( VAR IDENTIFIER ) | funccall | LPAREN ! expression RPAREN !);
	[GrammarRule("primary")]
	private AstParserRuleReturnScope<CommonTree, IToken> primary()
	{
		EnterRule_primary();
		EnterRule("primary", 12);
		TraceIn("primary", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INT79 = default(IToken);
		IToken FLOAT80 = default(IToken);
		IToken IDENTIFIER81 = default(IToken);
		IToken LPAREN83 = default(IToken);
		IToken RPAREN85 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> funccall82 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression84 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INT79_tree = default(CommonTree);
		CommonTree FLOAT80_tree = default(CommonTree);
		CommonTree IDENTIFIER81_tree = default(CommonTree);
		CommonTree LPAREN83_tree = default(CommonTree);
		CommonTree RPAREN85_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENTIFIER=new RewriteRuleITokenStream(adaptor,"token IDENTIFIER");
		try { DebugEnterRule(GrammarFileName, "primary");
		DebugLocation(85, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:86:5: ( INT | FLOAT | IDENTIFIER -> ^( VAR IDENTIFIER ) | funccall | LPAREN ! expression RPAREN !)
			int alt21=5;
			try { DebugEnterDecision(21, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt21 = 1;
				}
				break;
			case FLOAT:
				{
				alt21 = 2;
				}
				break;
			case IDENTIFIER:
				{
				alt21 = 3;
				}
				break;
			case CALL:
				{
				alt21 = 4;
				}
				break;
			case LPAREN:
				{
				alt21 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:86:7: INT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(86, 7);
				INT79=(IToken)Match(input,INT,Follow._INT_in_primary688); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INT79_tree = (CommonTree)adaptor.Create(INT79);
				adaptor.AddChild(root_0, INT79_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:87:7: FLOAT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(87, 7);
				FLOAT80=(IToken)Match(input,FLOAT,Follow._FLOAT_in_primary697); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FLOAT80_tree = (CommonTree)adaptor.Create(FLOAT80);
				adaptor.AddChild(root_0, FLOAT80_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:88:7: IDENTIFIER
				{
				DebugLocation(88, 7);
				IDENTIFIER81=(IToken)Match(input,IDENTIFIER,Follow._IDENTIFIER_in_primary705); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IDENTIFIER.Add(IDENTIFIER81);



				{
				// AST REWRITE
				// elements: IDENTIFIER
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 88:18: -> ^( VAR IDENTIFIER )
				{
					DebugLocation(88, 21);
					// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:88:21: ^( VAR IDENTIFIER )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(88, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VAR, "VAR"), root_1);

					DebugLocation(88, 27);
					adaptor.AddChild(root_1, stream_IDENTIFIER.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:89:7: funccall
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(89, 7);
				PushFollow(Follow._funccall_in_primary721);
				funccall82=funccall();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funccall82.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:90:7: LPAREN ! expression RPAREN !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(90, 13);
				LPAREN83=(IToken)Match(input,LPAREN,Follow._LPAREN_in_primary729); if (state.failed) return retval;
				DebugLocation(90, 15);
				PushFollow(Follow._expression_in_primary732);
				expression84=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression84.Tree);
				DebugLocation(90, 32);
				RPAREN85=(IToken)Match(input,RPAREN,Follow._RPAREN_in_primary734); if (state.failed) return retval;

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primary", 12);
			LeaveRule("primary", 12);
			LeaveRule_primary();
		}
		DebugLocation(91, 4);
		} finally { DebugExitRule(GrammarFileName, "primary"); }
		return retval;

	}
	// $ANTLR end "primary"

	partial void EnterRule_unaryexpr();
	partial void LeaveRule_unaryexpr();

	// $ANTLR start "unaryexpr"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:93:1: unaryexpr : ( PLUS !| negation ^)* primary ;
	[GrammarRule("unaryexpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> unaryexpr()
	{
		EnterRule_unaryexpr();
		EnterRule("unaryexpr", 13);
		TraceIn("unaryexpr", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken PLUS86 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> negation87 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> primary88 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree PLUS86_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unaryexpr");
		DebugLocation(93, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:95:5: ( ( PLUS !| negation ^)* primary )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:95:7: ( PLUS !| negation ^)* primary
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(95, 7);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:95:7: ( PLUS !| negation ^)*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=3;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==PLUS))
				{
					alt22 = 1;
				}
				else if ((LA22_0==MINUS))
				{
					alt22 = 2;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:95:8: PLUS !
					{
					DebugLocation(95, 12);
					PLUS86=(IToken)Match(input,PLUS,Follow._PLUS_in_unaryexpr754); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:95:16: negation ^
					{
					DebugLocation(95, 24);
					PushFollow(Follow._negation_in_unaryexpr759);
					negation87=negation();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(negation87.Tree, root_0);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }

			DebugLocation(95, 28);
			PushFollow(Follow._primary_in_unaryexpr764);
			primary88=primary();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primary88.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryexpr", 13);
			LeaveRule("unaryexpr", 13);
			LeaveRule_unaryexpr();
		}
		DebugLocation(96, 4);
		} finally { DebugExitRule(GrammarFileName, "unaryexpr"); }
		return retval;

	}
	// $ANTLR end "unaryexpr"

	partial void EnterRule_negation();
	partial void LeaveRule_negation();

	// $ANTLR start "negation"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:98:1: negation : MINUS -> NEGATE ;
	[GrammarRule("negation")]
	private AstParserRuleReturnScope<CommonTree, IToken> negation()
	{
		EnterRule_negation();
		EnterRule("negation", 14);
		TraceIn("negation", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken MINUS89 = default(IToken);

		CommonTree MINUS89_tree = default(CommonTree);
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		try { DebugEnterRule(GrammarFileName, "negation");
		DebugLocation(98, 1);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:99:2: ( MINUS -> NEGATE )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:99:4: MINUS
			{
			DebugLocation(99, 4);
			MINUS89=(IToken)Match(input,MINUS,Follow._MINUS_in_negation787); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_MINUS.Add(MINUS89);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 99:10: -> NEGATE
			{
				DebugLocation(99, 13);
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(NEGATE, "NEGATE"));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("negation", 14);
			LeaveRule("negation", 14);
			LeaveRule_negation();
		}
		DebugLocation(100, 1);
		} finally { DebugExitRule(GrammarFileName, "negation"); }
		return retval;

	}
	// $ANTLR end "negation"

	partial void EnterRule_multexpr();
	partial void LeaveRule_multexpr();

	// $ANTLR start "multexpr"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:102:1: multexpr : unaryexpr ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )* ;
	[GrammarRule("multexpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> multexpr()
	{
		EnterRule_multexpr();
		EnterRule("multexpr", 15);
		TraceIn("multexpr", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set91 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unaryexpr90 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryexpr92 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set91_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multexpr");
		DebugLocation(102, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:103:5: ( unaryexpr ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )* )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:103:7: unaryexpr ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(103, 7);
			PushFollow(Follow._unaryexpr_in_multexpr824);
			unaryexpr90=unaryexpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, unaryexpr90.Tree);
			DebugLocation(103, 17);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:103:17: ( ( MULTIPLY | DIVIDE ) ^ unaryexpr )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==DIVIDE||LA23_0==MULTIPLY))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:103:18: ( MULTIPLY | DIVIDE ) ^ unaryexpr
					{
					DebugLocation(103, 35);

					set91=(IToken)input.LT(1);
					set91=(IToken)input.LT(1);
					if (input.LA(1)==DIVIDE||input.LA(1)==MULTIPLY)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set91), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(103, 37);
					PushFollow(Follow._unaryexpr_in_multexpr834);
					unaryexpr92=unaryexpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, unaryexpr92.Tree);

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multexpr", 15);
			LeaveRule("multexpr", 15);
			LeaveRule_multexpr();
		}
		DebugLocation(104, 4);
		} finally { DebugExitRule(GrammarFileName, "multexpr"); }
		return retval;

	}
	// $ANTLR end "multexpr"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:107:1: expression : multexpr ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 16);
		TraceIn("expression", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set94 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> multexpr93 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> multexpr95 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set94_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(107, 4);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:109:5: ( multexpr ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )* )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:109:7: multexpr ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(109, 7);
			PushFollow(Follow._multexpr_in_expression860);
			multexpr93=multexpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, multexpr93.Tree);
			DebugLocation(109, 16);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:109:16: ( ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==AND||LA24_0==EQUALS||(LA24_0>=GT && LA24_0<=GTEQ)||(LA24_0>=LT && LA24_0<=MINUS)||(LA24_0>=OR && LA24_0<=PLUS)))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:109:17: ( PLUS | MINUS | EQUALS | GT | GTEQ | LT | LTEQ | AND | OR ) ^ multexpr
					{
					DebugLocation(109, 59);

					set94=(IToken)input.LT(1);
					set94=(IToken)input.LT(1);
					if (input.LA(1)==AND||input.LA(1)==EQUALS||(input.LA(1)>=GT && input.LA(1)<=GTEQ)||(input.LA(1)>=LT && input.LA(1)<=MINUS)||(input.LA(1)>=OR && input.LA(1)<=PLUS))
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set94), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(109, 61);
					PushFollow(Follow._multexpr_in_expression884);
					multexpr95=multexpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multexpr95.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 16);
			LeaveRule("expression", 16);
			LeaveRule_expression();
		}
		DebugLocation(110, 4);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_synpred7_MyLangParser_fragment();
	partial void LeaveRule_synpred7_MyLangParser_fragment();

	// $ANTLR start synpred7_MyLangParser
	public void synpred7_MyLangParser_fragment()
	{
		EnterRule_synpred7_MyLangParser_fragment();
		EnterRule("synpred7_MyLangParser_fragment", 23);
		TraceIn("synpred7_MyLangParser_fragment", 23);
		try
		{
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:65: ( WS )
			DebugEnterAlt(1);
			// D:\\development\\cvsout\\MyLanguage\\MyLanguageGrammar\\Grammar\\MyLangParser.g:33:65: WS
			{
			DebugLocation(33, 65);
			Match(input,WS,Follow._WS_in_synpred7_MyLangParser227); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred7_MyLangParser_fragment", 23);
			LeaveRule("synpred7_MyLangParser_fragment", 23);
			LeaveRule_synpred7_MyLangParser_fragment();
		}
	}
	// $ANTLR end synpred7_MyLangParser
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _IDENTIFIER_in_identifier137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WS_in_runprogram153 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _RUN_in_runprogram156 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_runprogram158 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _PROGRAM_in_runprogram160 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_runprogram162 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_runprogram164 = new BitSet(new ulong[]{0x8000000010000UL});
		public static readonly BitSet _WS_in_runprogram166 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ENDP_in_runprogram170 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOF_in_runprogram174 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WS_in_program204 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _DECLARE_in_program207 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_program209 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _PROGRAM_in_program211 = new BitSet(new ulong[]{0x8000000000100UL});
		public static readonly BitSet _WS_in_program213 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_program216 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_program218 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _identifier_in_program220 = new BitSet(new ulong[]{0x8000020000000UL});
		public static readonly BitSet _WS_in_program222 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _LCURLY_in_program225 = new BitSet(new ulong[]{0x8000020000800UL});
		public static readonly BitSet _WS_in_program227 = new BitSet(new ulong[]{0x8000020000800UL});
		public static readonly BitSet _funcdecl_in_program230 = new BitSet(new ulong[]{0x8000020000800UL});
		public static readonly BitSet _WS_in_program233 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_program236 = new BitSet(new ulong[]{0x8010000000000UL});
		public static readonly BitSet _WS_in_program238 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _RCURLY_in_program241 = new BitSet(new ulong[]{0x8000000010000UL});
		public static readonly BitSet _WS_in_program243 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ENDP_in_program247 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOF_in_program252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_blockstatement279 = new BitSet(new ulong[]{0x4030026000000UL});
		public static readonly BitSet _statement_in_blockstatement281 = new BitSet(new ulong[]{0x4030026000000UL});
		public static readonly BitSet _RCURLY_in_blockstatement284 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_assignment315 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_assignment317 = new BitSet(new ulong[]{0x224A080080UL});
		public static readonly BitSet _expression_in_assignment319 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_ifstatement353 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_ifstatement355 = new BitSet(new ulong[]{0x224A080080UL});
		public static readonly BitSet _expression_in_ifstatement358 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _RPAREN_in_ifstatement360 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _THEN_in_ifstatement363 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_ifstatement375 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _ELSE_in_ifstatement392 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_ifstatement404 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_whilestatement434 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_whilestatement436 = new BitSet(new ulong[]{0x224A080080UL});
		public static readonly BitSet _expression_in_whilestatement439 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _RPAREN_in_whilestatement441 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_whilestatement444 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_returnstatement461 = new BitSet(new ulong[]{0x224A080080UL});
		public static readonly BitSet _expression_in_returnstatement464 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignment_in_statement497 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _ifstatement_in_statement506 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _returnstatement_in_statement514 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _whilestatement_in_statement522 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _blockstatement_in_statement530 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _SEMI_in_statement550 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WS_in_funcdecl569 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _DECLARE_in_funcdecl572 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_funcdecl574 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _FUNCTION_in_funcdecl576 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_funcdecl578 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_funcdecl580 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_funcdecl582 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl584 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _WS_in_funcdecl586 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_funcdecl588 = new BitSet(new ulong[]{0x40002000000UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl591 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _COMMA_in_funcdecl594 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_funcdecl596 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _RPAREN_in_funcdecl602 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _blockstatement_in_funcdecl604 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CALL_in_funccall636 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _IDENTIFIER_in_funccall638 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LPAREN_in_funccall640 = new BitSet(new ulong[]{0x4224A080080UL});
		public static readonly BitSet _expression_in_funccall643 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _COMMA_in_funccall646 = new BitSet(new ulong[]{0x224A080080UL});
		public static readonly BitSet _expression_in_funccall648 = new BitSet(new ulong[]{0x40000000200UL});
		public static readonly BitSet _RPAREN_in_funccall654 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_primary688 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_primary697 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENTIFIER_in_primary705 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funccall_in_primary721 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_primary729 = new BitSet(new ulong[]{0x224A080080UL});
		public static readonly BitSet _expression_in_primary732 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _RPAREN_in_primary734 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_unaryexpr754 = new BitSet(new ulong[]{0x224A080080UL});
		public static readonly BitSet _negation_in_unaryexpr759 = new BitSet(new ulong[]{0x224A080080UL});
		public static readonly BitSet _primary_in_unaryexpr764 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_negation787 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryexpr_in_multexpr824 = new BitSet(new ulong[]{0x400002002UL});
		public static readonly BitSet _set_in_multexpr827 = new BitSet(new ulong[]{0x224A080080UL});
		public static readonly BitSet _unaryexpr_in_multexpr834 = new BitSet(new ulong[]{0x400002002UL});
		public static readonly BitSet _multexpr_in_expression860 = new BitSet(new ulong[]{0x3381820012UL});
		public static readonly BitSet _set_in_expression863 = new BitSet(new ulong[]{0x224A080080UL});
		public static readonly BitSet _multexpr_in_expression884 = new BitSet(new ulong[]{0x3381820012UL});
		public static readonly BitSet _WS_in_synpred7_MyLangParser227 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  MyLanguageImpl.Grammar 
